\documentclass[colorlinks]{beamer}
  % compress
  %\documentclass[handout,xcolot=pdftex,dvipsnames,table]{beamer}
%\definecolor{mybg}{RGB}{255,255,204}
\definecolor{mybg}{RGB}{238,255,170}
\usepackage{minted}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{color}
\usepackage[utf8x]{inputenc}
%\usepackage{amsmath}
%\usepackage{beamerthemesplit}
%\usemintedstyle{trac}
\input{format.tex}
\begin{document}
\setcounter{tocdepth}{2}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}
\title{ Python in a Nutshell}
\subtitle
 {Part I: Python, ipython, language and OOP } % (optional)
\input{header.tex} %

%----------------------------FRAME------------------------------------
\begin{frame}[plain]
   %  \titlepage
   \maketitle
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[allowframebreaks]{Contents}
  \tableofcontents
  % You might wish to add the option [pausesections]
 \note[options]{aixo son notes}
\end{frame}
%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------
\section{Introduction}



\subsection{Why Learn Python}
%----------------------------FRAME------------------------------------

\begin{frame}\frametitle{The scientist’s needs}
\small
\begin{itemize}
    \item Get data (simulation, experiment control)
    \item Manipulate and process data.
    \item Visualize results... to understand what we are doing!
    \item Communicate results: produce figures for reports or publications, write presentations.
\end{itemize}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Specifications}
\small
  \begin{itemize}
    \item We don’t want to re-program the plotting of a curve, a Fourier transform or a fitting algorithm. Don’t reinvent the wheel! We need building blocks 
    \item Easy to learn: computer science is neither our job nor our education
    \item The code should be as readable as a book
    \item Efficient code that executes quickly... but needless to say that a very fast code becomes useless if we spend too much time writing it. So, we need both a quick development time and a quick execution time
    \item A single environment/language for everything
\end{itemize}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}\frametitle{ Existing solutions I}
\begin{itemize}
    \item Compiled languages: C, C++, Fortran, etc.
        \begin{itemize}
            \item Advantages:
                \begin{itemize}
                    \item \tiny Very fast. Very optimized compilers. For heavy computations, it’s difficult to outperform these languages.
                    \item \tiny Some very optimized scientific libraries have been written for these languages. Example: BLAS (vector/matrix operations)
                \end{itemize}
            \item Drawbacks:
                \begin{itemize}
                    \item \tiny Painful usage: no interactivity during development, mandatory compilation steps, verbose syntax (*, **, ::, \} , ; etc.), manual memory management (tricky in C). These are \textbf{difficult languages} for non computer scientists.
                 \end{itemize}
        \end{itemize}
 \end{itemize}

\end{frame}
\begin{frame}\frametitle{ Existing solutions II}
\begin{itemize}
    \item Scripting languages: Matlab   
        \begin{itemize}
            \item Advantages:
                \begin{itemize}
                    \item \tiny Very rich collection of libraries with numerous algorithms, for many different domains. Fast execution because these libraries are often written in a compiled language.
                    \item \tiny Pleasant development environment: comprehensive and well organized help, integrated editor, etc.
                    \item \tiny Commercial support is available. 
                \end{itemize}
            \item Drawbacks:
                \begin{itemize}
                    \item \tiny Base language is quite poor and can become restrictive for advanced users.
                    \item \textbf{Not free }
                \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}\frametitle{ Existing solutions III}
 \begin{itemize}
    \item Other scripting languages: Scilab, Octave, Igor, R, IDL, etc.
        \begin{itemize}
            \item Advantages:
                \begin{itemize}
                     \item \tiny Open-source, free, or at least cheaper than Matlab.
                    \item \tiny Some features can be very advanced (statistics in R, figures in Igor, etc.)\end{itemize}
            \item Drawbacks:
                \begin{itemize}
                    \item \tiny Fewer available algorithms than in Matlab, and the language is not more advanced.
                    \item \tiny Some software are dedicated to one domain. Ex: Gnuplot or xmgrace to draw curves. These programs are very powerful, but they are restricted to a single type of usage, such as plotting.
                \end{itemize}
        \end{itemize}
\end{itemize}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Why not?}

 \begin{itemize}
    \item What about Python?
        \begin{itemize}
            \item Advantages:
                \begin{itemize}
                     \item \tiny Very rich scientific computing libraries (a bit less than Matlab, though)
                    \item \tiny Well thought out language, allowing to write very readable and well structured code: we “code what we think”.
                    \item \tiny Many libraries for other tasks than scientific computing (web server management, serial port access, etc.)
                    \item \tiny Free and open-source software, widely spread, with a vibrant community.
                \end{itemize}
            \item Drawbacks:
                \begin{itemize}
                    \item \tiny Less pleasant development environment than, for example, Matlab. (More geek-oriented).
                    \item \tiny Not all the algorithms that can be found in more specialized software or toolboxes. 
                \end{itemize}
        \end{itemize}
\end{itemize}
\begin{block}{\begin{center}
    It is not a must
\end{center}}
\begin{center}
You don't need to use Python... but  what the hell,\\ \textbf{why not?}\end{center}
\end{block}


\end{frame}

\subsection{Python History}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{History}
\begin{columns}[T]
    \begin{column}{.7\textwidth}
        \begin{block}{\centering History}
\small
            \begin{itemize}
                 \item Python 1.0 - January 1994
                    \begin{itemize}
\tiny
                        \item Python 1.5 - December 31, 1997
                        \item Python 1.6 - September 5, 2000
                    \end{itemize}
                \item Python 2.0 - October 16, 2000
                    \begin{itemize}
\tiny
                        \item Python 2.1 - April 17, 2001
                        \item Python 2.2 - December 21, 2001
                        \item Python 2.3 - July 29, 2003
                        \item Python 2.4 - November 30, 2004
                        \item Python 2.5 - September 19, 2006
                        \item Python 2.6 - October 1, 2008
                        \item \textbf{Python 2.7 - July 3, 2010}
                    \end{itemize}
                \item Python 3.0 - December 3, 2008
                    \begin{itemize}
\tiny
                        \item Python 3.1 - June 27, 2009
                        \item Python 3.2 - February 20, 2011
                        \item Python 3.3 - September 29, 2012
                    \end{itemize}
            \end{itemize}
        \end{block}
    \end{column}
    \begin{column}{.3\textwidth}
        \begin{block}{ \centering  Guido van Rossum}
            \begin{center}
                Conceived in the late 1980s by 
                \includegraphics[scale=0.2]{figs/Guido_van_Rossum.jpg}
            \end{center}
        \end{block}
    \end{column}
  \end{columns}
\end{frame}


\subsection{Installing Python}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Installation}

  \begin{columns}[T]
    \begin{column}{.4\textwidth}
        \begin{block}{\centering Linux}
\begin{center}
    \includegraphics[scale=0.3]{figs/linux.jpg}
\end{center}
                  apt-get install python
        \end{block}
    \end{column}
    \begin{column}{.6\textwidth}
        \begin{block}{ \centering  Windows}
\centering

\begin{center}
\includegraphics[scale=0.3]{figs/windows.jpg}
\end{center}    
            Go to \textbf{http://www.python.org/getit/}
            and download 
\textbf{Python 2.7.3 Windows Installer}
        \end{block}        
    \end{column}
  \end{columns}
\end{frame}



\subsection{Python Resources}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Resources}
\begin{block}{HELP!!!}
\textbf{http://python.org}
\begin{center}
\includegraphics[scale=0.15]{figs/python__org.jpg}
\end{center}  
\end{block}
  
\end{frame}
%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------

\section{Working with Python}

\subsection{Workflow}

%----------------------------FRAME------------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/workflow.pdf}
}

\begin{frame}[fragile]\frametitle{Workflow}
\end{frame}
}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Python core}
 
 \begin{columns}[T]
    \begin{column}{.7\textwidth}
        \begin{block}{\centering Python Core}
\small Python is open, is just an specification, thus there are many Python implementations:
\begin{description}
\scriptsize    
    \item[CPython] The default (C, C++)
    \item[CLPython] Lisp implementation of Python
    \item[Jython] The java implementation of Python
    \item[PyPy] The python implementation of Python
    \item [IronPython] C\# implementation
\end{description}
        \end{block}
    \end{column}
    \begin{column}{.3\textwidth}
\begin{center}
Python Core
\includegraphics[scale=0.3]{figs/gears.jpg}
\end{center}    
    \end{column}
  \end{columns}
\end{frame}


\subsection{ipython vs. CLI}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Python Shell}
        \begin{block}{\centering Python Shell}
\small There are many tools to drive directly with Python, the most remarkable are: 
    \begin{description}
\scriptsize    
        \item[CLIPython] The default one
        \item[IPython] Enhanced (VERY enhanced) default shell
    \end{description}
\end{block}
\begin{figure}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{figs/commandline.jpg}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{figs/commandline2.jpg}
\end{minipage}
\end{figure}    
\end{frame}




\subsection{Text Editors} % (fold)
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Text editors}
\begin{block}{Script editors}
 Any text editor is well suited for creating scripts with python, we recommend some features on it:
\begin{itemize}
    \item Tab substitution
    \item Code snippets
    \item Autocompletion
\end{itemize}
In the Linux wild, Vim and Emacs are both well suited.
\end{block}

\end{frame}

\subsection{IDEs}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{IDEs}
 \begin{block}{Most Valuable IDEs}
 \begin{description}
     \item[Spyder] The Matlab-like environment, scientist oriented.
    % \item [EDP] Enthought Python Distribution, complete set of tools.
Scientist oriented
     \item[Eclipse-PyDEV] Big project oriented  
 \end{description}
 \end{block}
\begin{center}
    \textbf{DEMO}
\end{center}

\end{frame}

\subsection{Notebook}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Notebook}
\begin{block}{An HTML Notebook IPython}
The IPython Notebook consists of two related components:
\begin{itemize}
    \item An JSON based Notebook document format for recording and distributing Python code and rich text.
\item A \textbf{web-based user interface} for authoring and running notebook documents.
\end{itemize}
\end{block}
\begin{center}
    \textbf{DEMO}
\end{center}
\end{frame}

%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------


\section{Getting Started With Python}

\subsection{Introduction}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{First step}
\begin{block}{\centering STEP 1}
\centering Start the interpreter and type in
\end{block}
  %-------------------------------CODE
<<term=TRUE,echo=TRUE>>=
print "Hello, world"
@
\begin{block}{}
\centering Welcome to Python,\\ you just executed your first Python instruction, congratulations!
\end{block}
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Second step}
\vspace{-0.1cm}
\begin{block}{\centering STEP 2}
\centering To get yourself started, type the following stack of instructions
\end{block}
 \begin{columns}[T]
\begin{column}{.5\textwidth}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE>>=
a = 3
b = 2*a
type(b)
print b
a*b
b = 'hello'
type(b)
b + b
2*b
@
%-------------------------------END CODE

\end{column}
    \begin{column}{.5\textwidth}
\end{column}
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Second step}
\vspace{-0.1cm}
\begin{block}{\centering STEP 2}
\centering To get yourself started, type the following stack of instructions
\end{block}
 \begin{columns}[T]
\begin{column}{.5\textwidth}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE>>=
a = 3
b = 2*a
type(b)
print b
a*b
b = 'hello'
type(b)
b + b
2*b
@
%-------------------------------END CODE

\end{column}
    \begin{column}{.5\textwidth}
    \begin{block}{\centering Observe that}
            \begin{itemize}
\scriptsize    
                \item We do not declare variables (hurrah!!!!!) 
                \item Variable type may be changed on the fly (hurrah!!!, hurrah!!!)
                \item There is a way to overload operators (hurrah!, hurrah!, hurrah!!!)\\
                \item There is a function that tell us the type of a variable.
            \end{itemize}
       \end{block}

\end{column}
\end{columns}
\end{frame}

\subsection{Basic Types}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Types}
 \begin{columns}[T]
\begin{column}{.5\textwidth}
   \begin{block}{Integer}
 %-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
1+1
a=4
@
 %-------------------------------END CODE
  \end{block}
 \begin{block}{Boolean}
%-------------------------------CODE
\tiny
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
3 > 4
test = (3 > 4)
test
type(test)
@
%-------------------------------END CODE
\end{block}
\end{column}
    \begin{column}{.5\textwidth}
 \begin{block}{Float}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
c=2.1
3.5/c
@

%-------------------------------END CODE
\end{block}
  \begin{block}{Complex}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a=1.5+0.5j
a.real
a.imag
import cmath
cmath.phase(a)
@
%-------------------------------END CODE  
  \end{block}

\end{column}
\end{columns}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Basic Calculator}
\begin{block}{A Python shell can therefore replace your pocket calculator, with the basic arithmetic operations +, -, *, /, \% (modulo) natively implemented:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
7 * 3.
2**10
8 % 3
@
%-------------------------------END CODE
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{WARNING!}
\begin{block}{Integer Division}
%-------------------------------CODE
\small
<<term=TRUE,echo=TRUE,fig=FALSE>>=
3/2
@
%-------------------------------END CODE
\end{block}
\begin{block}{Use floats}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
3 / 2.
a = 3
b = 2
a / b
a / float(b)
@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
Python provides many efficient types of containers, in which collections of objects can be stored.
\begin{block}{Lists}
A list is an ordered collection of objects, that may have different types. For example
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l = [1, 2, 3, 4, 5]
type(l)
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
\begin{block}{accessing individual objects contained in the list:}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l[2]
@
%-------------------------------END CODE
\end{block}
\begin{block}{Counting from the end with negative indices:}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l[-1]
l[-2]
@
%-------------------------------END CODE
\end{block}
\begin{block}{{\color{green}\textbf{Warning Indexing starts at 0} }}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l[0]
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
\begin{block}{Slicing}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l
l[2:4]
@
%-------------------------------END CODE

\end{block}
\begin{block}{{\color{green}\textbf{Warning} }}
Warning Note that \textbf{l[start:stop]} contains the elements with indices i such as start $\le$ i $<$ stop (i ranging from start to stop-1). Therefore, \textbf{l[start:stop] has (stop-start) elements}.
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
\begin{block}{}
Slicing syntax: l[start:stop:step]
\end{block}
\begin{block}{All slicing parameters are optional:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l
l[3:]
l[:3]
l[::2]
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
\begin{block}{The elements of a list may have different types:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l = [3, 2+3j, 'hello']
l
l[1], l[2]
@
%-------------------------------END CODE
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
\vspace{-0.2cm}
\small
Python offers a large panel of functions to modify lists, or query them. Here are a few examples; for more details, see \href{http://docs.python.org/tutorial/datastructures.html#more-on-lists}{http://docs.python.org/tutorial/datastructures.html\#more-on-lists}
\vspace{-0.2cm}
\begin{block}{Add and remove elements}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l = [1, 2, 3, 4, 5]
l.append(6)
l
l.pop()
l
l.extend([6, 7]) # extend l, in-place
l
l = l[:-2]
l
@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Lists}
\vspace{-0.2cm}
\begin{block}{Reverse list}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
r = l[::-1]
r
@
%-------------------------------END CODE
\end{block}
\vspace{-0.2cm}
\begin{block}{Concatenate and repeat}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
r + l
2 * r
@
%-------------------------------END CODE

\end{block}
\vspace{-0.2cm}
\begin{block}{Sort (in-place)}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
r.sort()
r
@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Note}
\begin{block}{Methods and Object-Oriented Programming}
The notation r.method() (r.sort(), r.append(3), l.pop()) is our first example of object-oriented programming (OOP). Being a list, the object r owns the method function that is called using the notation '.'\\ No further knowledge of OOP than understanding the notation '.' is necessary for going through this tutorial.
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Note}
\begin{block}{Discovering methods in ipython\\ tab-completion (press tab)}

\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: r.
r.append   r.extend   r.insert   r.remove   r.sort     
r.count    r.index    r.pop      r.reverse 
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Strings}
\begin{block}{}
%-------------------------------CODE
\small
<<term=False,echo=TRUE,fig=FALSE>>=
s = 'Hello, how are you?'
s = "Hi, what's up"
s = '''Hello,                
       how are you'''# tripling the quotes allows the 
s = """Hi,
       what's up?""" # the string to span more than one line
@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Strings}
\begin{block}{Indexing strings}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a = "hello"
a[0]
a[1]
a[-1]
@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Strings}
\begin{block}{Substitution}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
'An integer: %i; a float: %f; another string: %s' % (1, 0.1, 'string')
i = 102.1
filename = 'processing_of_dataset_%03d.txt'%i
filename
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
  \begin{block}{5 seconds challenge}
  In ipython, create a list and check its methods with the tab-completion feature
  \end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Strings}
\begin{block}{Slicing}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a = "hello, world!"
a[3:6] # 3rd to 6th (excluded) elements: elements 3, 4, 5
a[2:10:2] # Syntax: a[start:stop:step]
a[::3] # every three characters, from beginning to end
@
%-------------------------------END CODE
\end{block}
BUT...
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Strings}
\begin{block}{You can't change them in this way}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: a = "hello, world!"
In [2]: a[2] = 'z'
-----------------------------------------------------------
TypeError              Traceback (most recent call last)

/home/mvelasco/Curs_Python/<ipythonconsole> in <module>()

TypeError: 'str' object does not support item assignment

\end{minted}
\end{block}
    \centering
    \includegraphics[scale=0.5]{figs/grito.jpg}
\end{frame}

\subsection{Mutable and immutable}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{PAY ATTENTION}
\begin{block}{}
\centering
\huge
{\color{red}\textbf{NEXT SET OF SLIDES ARE VERY IMPORTANT!!!}}
\end{block}
\end{frame}
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Mutable and immutable types}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Immutable types}
\begin{itemize}
    \item integer
\item float
\item complex
\item boolean 
\item strings
\end{itemize}
\end{block}
\column{0.5\textwidth}
\begin{block}{Mutable}
\begin{itemize}
    \item Lists
\end{itemize}
\end{block}
\end{columns}
\end{frame}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/mutable1.pdf}
}

\begin{frame}[fragile]\frametitle{Immutable types}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Create an immutable element}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a=32
@
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\end{columns}

\end{frame}
}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/mutable2.pdf}
}

\begin{frame}[fragile]\frametitle{Immutable types}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{block}{"copy" it}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a=32
b=a
@
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\end{columns}

\end{frame}
}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/mutable3.pdf}
}

\begin{frame}[fragile]\frametitle{Immutable types}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{block}{Change the original object}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a=32
b=a
a=10
b
@
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\end{columns}

\end{frame}
}
%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/mutable4.pdf}
}

\begin{frame}[fragile]\frametitle{Mutable types}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{block}{Create a mutable type}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l=[32,10]
@
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\end{columns}

\end{frame}
}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/mutable5.pdf}
}

\begin{frame}[fragile]\frametitle{Mutable types}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{block}{"Copy" it}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l=[32,10]
r=l
@
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\end{columns}

\end{frame}
}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/mutable6.pdf}
}

\begin{frame}[fragile]\frametitle{Mutable types}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{block}{Change the original object}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
l=[32,10]
r=l
l[1]=3
r
@
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\end{columns}

\end{frame}
}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
  \begin{block}{1 minute challenge}
  Create a list A, create a list B that contains A, copy the list B into C, modify A and check C value
  \end{block}
\end{frame}

%----------------------------FRAME 2 cols------------------------------

\begin{frame}[fragile]\frametitle{Visited Types}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{block}{Already seen types}
\begin{itemize}
    \item boolean
\item integer
\item float
\item complex
\item string
\item list
\end{itemize}
\end{block}
\column{0.5\textwidth}
\begin{block}{Pending Types}
\begin{itemize}
    \item Dictionary
\item Tuple
\item Set
\end{itemize}
\end{block}
\end{columns}

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Dictionary}
  \begin{block}{A dictionary is basically an efficient table that maps keys to values. It is an unordered container:}
  %-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
tel = {'emmanuelle': 5752, 'sebastian': 5578}
tel['francis'] = 5915
tel
tel['sebastian']
tel.keys()
tel.values()
'francis' in tel
@
  %-------------------------------END CODE
  \end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Dictionary}
\begin{block}{A dictionary can have keys (resp. values) with different types:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
d = {'a':1, 'b':2, 3:'hello'}
d
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{1 minute challenge}
Are Dicts mutable?
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Tuples}
\begin{block}{The elements of a tuple are written between parentheses, or just separated by commas:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
t = 12345, 54321, 'hello!'
t[0]
t
u = (0, 2)
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Sets}
\begin{block}{unordered, unique items:}
 %-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
s = set(('a', 'b', 'c', 'a'))
s
s.difference(('a', 'b'))
@
 %-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
  \begin{block}{2 minutes challenge}
\begin{itemize}
    \item Are tuples mutable?
\item Which are the methods of tuples?
\item Are Sets mutable?
\item Which are de methods of sets?
\end{itemize}
  
  \end{block}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Before going on...}
\begin{block}{Built-in functions}
\tiny
\begin{verbatim}
abs()	        divmod()	   input()	     open()	    staticmethod()
all()	        enumerate()	int()	       ord()	     str()
any()	        eval()	     isinstance()	pow()	     sum()
basestring()	 execfile()	 issubclass()	print()	   super()
bin()	        file()	     iter()	      property()	tuple()
bool()	       filter()	   len()	       range()	   type()
bytearray()	  float()	    list()	      raw_input()unichr()
callable()	   format()	   locals()	    reduce()	  unicode()
chr()	        frozenset()	long()	      reload()	  vars()
classmethod()	getattr()	  map()	       repr()	    xrange()
cmp()	        globals()	  max()	       reversed() zip()
compile()	    hasattr()	  memoryview() round()	   __import__()
complex()	    hash()	     min()	       set()	     apply()
delattr()	    help()	     next()	      setattr()	 buffer()
dict()	       hex()	      object()	    slice()	   coerce()
dir()	        id()	       oct()	       sorted()	  intern()
\end{verbatim}

\end{block}

\end{frame}


\subsection{Controlling execution flow}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{if/then/else}
\begin{block}{If}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
if 2**2 == 4:
    print 'Obvious!'
@
%-------------------------------END CODE

\end{block}
\begin{block}{Blocks are delimited by indentation}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a = 10
if a == 1:
    print(1)
elif a == 2:
    print(2)
else:
    print('A lot')

@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Conditional Expressions¶}
\begin{columns}[c]
\column{0.5\textwidth}
\tiny
\begin{block}{if object:}
Evaluates to False:
\begin{itemize}
    \item any number equal to zero (0, 0.0, 0+0j)
\item an empty container (list, tuple, set, dictionary, ...)
\item False, None
\end{itemize}  
Evaluates to True:
\begin{itemize}
    \item everything else (User-defined classes can customize those rules by overriding the special \textbf{nonzero} method.)
\end{itemize}
\end{block}

\begin{block}{Tests equality, with logics:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
1==1.
@
%-------------------------------END CODE
\end{block}


\column{0.5\textwidth}
\tiny
\begin{block}{Tests identity: both sides are the same object:}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
1 is 1.
a = 1
b = 1
a is b
@
%-------------------------------END CODE
\end{block}
\begin{block}{For any collection b: b contains a}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
b = [1, 2, 3]
2 in b
5 in b
@
If b is a dictionary, this tests that a is a key of b.
%-------------------------------END CODE
\end{block}

\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{for/range}
  \begin{block}{Iterating with an index:}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
for i in range(4):
    print(i)
@
%-------------------------------END CODE
  \end{block}
\begin{block}{But most often, it is more readable to iterate over values:}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
for word in ('cool', 'powerful', 'readable'):
   print('Python is %s' % word)
@
%-------------------------------END CODE
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{ while/break/continue¶}
\begin{columns}[T]
\column{0.5\textwidth}

\begin{block}{Typical C-style while loop (Mandelbrot problem):}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
z = 1 + 1j
while abs(z) < 100:
   z = z**2 + 1
@
%-------------------------------END CODE
\end{block}

\begin{block}{Break out of enclosing for/while loop:}
\tiny
%-------------------------------CODE
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> z = 1 + 1j
>>> while abs(z) < 100:
...     if z.imag == 0:
...         break
...     z = z**2 + 1
\end{minted}
%-------------------------------END CODE
\end{block}
\column{0.5\textwidth}
\begin{block}{Continue the next iteration of a loop.:}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a = [1, 0, 2, 4]
for element in a:
    if element == 0:
        continue
    print 1. / element

@
%-------------------------------END CODE
\end{block}
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Advanced iteration}
\begin{block}{Iterate over any sequence}
\tiny
You can iterate over any sequence (string, list, keys in a dictionary, lines in a file, ...):
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
vowels = 'aeiou'
for i in 'powerful':
    if i in vowels:
        print(i),
@
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
message = "Hello how are you?"
message.split() # returns a list
for word in message.split():
    print word,
@
%-------------------------------END CODE
%-------------------------------END CODE
Few languages (in particular, languages for scientific computing) allow to loop over anything but integers/indices. With Python it is possible to loop exactly over the objects of interest without bothering with indices you often don’t care about.
\end{block}

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Keeping track of enumeration number}
Common task is to iterate over a sequence while keeping track of the item number.
\begin{block}{Could use while loop with a counter as above. Or a for loop:}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
words = ('cool', 'powerful', 'readable')
for i in range(0, len(words)):
    print(i, words[i]),
@
%-------------------------------END CODE
\end{block}
\begin{block}{But Python provides enumerate for this:}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
words = ('cool', 'powerful', 'readable')
for index, item in enumerate(words):
    print index, item,
@
%-------------------------------END CODE
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Looping over a dictionary}
\begin{block}{Use iteritems:}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
d = {'a': 1, 'b':1.2, 'c':1j}
for key, val in d.iteritems():
    print('Key: %s has value: %s' % (key, val))
@
%-------------------------------END CODE
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{List comprehensions}
\begin{block}{Natural math}
\[
k=\left\{x^2, x \in \left\{0,1,2,3\right\}\right\}
\]
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
k=[x**2 for x in range(4)]
k
@
%-------------------------------END CODE
\end{block}




\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{5 minutes challenge}
Compute the decimals of $\pi$ using the Wallis formula:
\[
\pi=2\prod_{i=1}^{\infty}\frac{4i^2}{4i^2-1}
\]
\end{block}

\end{frame}


\subsection{Exception handling}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Exceptions}
\begin{block}{Exceptions are raised by errors in Python:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: 1/0
---------------------------------------------------------------------------
ZeroDivisionError: integer division or modulo by zero
In [2]: 1 + 'e'
---------------------------------------------------------------------------
TypeError: unsupported operand type(s) for +: 'int' and 'str'
In [3]: d = {1:1, 2:2}
In [4]: d[3]
---------------------------------------------------------------------------
KeyError: 3
In [5]: l = [1, 2, 3]
In [6]: l[4]
---------------------------------------------------------------------------
IndexError: list index out of range
In [7]: l.foobar
---------------------------------------------------------------------------
AttributeError: 'list' object has no attribute 'foobar'
\end{minted}
\end{block}


\end{frame}



%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Catching exceptions}
\begin{block}{try/except}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [8]: while True:
 ....:     try:
 ....:         x = int(raw_input('Please enter a number: '))
 ....:         break
 ....:     except ValueError:
 ....:         print('That was no valid number.  Try again...')
 ....:
 ....:
Please enter a number: a
That was no valid number.  Try again...
Please enter a number: 1

In [9]: x
Out[9]: 1
\end{minted}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Catching exceptions}
\begin{block}{try/finally}

Important for resource management (e.g. closing a file)
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [10]: try:
   ....:    x = int(raw_input('Please enter a number: '))
   ....: finally:
   ....:    print('Thank you for your input')
   ....:
   ....:
Please enter a number: a
Thank you for your input
---------------------------------------------------------------------------
ValueError: invalid literal for int() with base 10: 'a'
\end{minted}
\end{block}
There are many tricks with the exceptions, but they are out of the scope of these slides


\end{frame}

%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------


\section{Functions and Object Oriented Programming}
\subsection{Defining New Functions}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Function definition}
\begin{block}{Function blocks must be indented as other control-flow blocks.}
%-------------------------------CODE
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [56]: def test():
   ....:     print('in test function')
   ....:
   ....:

In [57]: test()
in test function
\end{minted}
%-------------------------------END CODE
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Return statement}
\begin{block}{Functions can optionally return values.}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [6]: def disk_area(radius):
   ...:     return 3.14 * radius * radius
   ...:

In [8]: disk_area(1.5)
Out[8]: 7.0649999999999995
\end{minted}
Structure:
\begin{itemize}
\item the def keyword;
\item is followed by the function’s name, then
\item the arguments of the function are given between brackets followed by a colon.
\item he function body ;
\item and return object for optionally returning values.
    \item By default, functions return None.
\end{itemize}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Parameters}


\begin{block}{Mandatory parameters (positional arguments)}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [81]: def double_it(x):
   ....:     return x * 2
   ....:

In [82]: double_it(3)
Out[82]: 6

In [83]: double_it()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/Users/cburns/src/scipy2009/scipy_2009_tutorial/source/<ipython console> in <module>()

TypeError: double_it() takes exactly 1 argument (0 given)
\end{minted}
\end{block}
\end{frame}


\begin{frame}[fragile]\frametitle{Parameters}



\begin{block}{Optional parameters (keyword or named arguments)}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [84]: def double_it(x=2):
   ....:     return x * 2
   ....:
In [85]: double_it()
Out[85]: 4
In [86]: double_it(3)
Out[86]: 6
\end{minted}
\end{block}
\begin{block}{Warning}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [124]: bigx = 10
In [125]: def double_it(x=bigx):
   .....:     return x * 2
   .....:
In [126]: bigx = 1e9  # Now really big
In [128]: double_it()
Out[128]: 20
\end{minted}

\end{block}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Parameters}
\begin{block}{More involved example implementing python’s slicing:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [98]: def slicer(seq, start=None, stop=None, step=None):
   ....:     """Implement basic python slicing."""
   ....:     return seq[start:stop:step]
   ....:

In [101]: rhyme = 'one fish, two fish, red fish, blue fish'.split()

In [102]: rhyme
Out[102]: ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']

In [103]: slicer(rhyme)
Out[103]: ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']

In [104]: slicer(rhyme, step=2)
Out[104]: ['one', 'two', 'red', 'blue']

In [105]: slicer(rhyme, 1, step=2)
Out[105]: ['fish,', 'fish,', 'fish,', 'fish']

In [106]: slicer(rhyme, start=1, stop=4, step=2)
Out[106]: ['fish,', 'fish,']
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Parameters and mutability}
\begin{block}{5 minutes challenge}
Check the behaviour of mutable and no mutable parameters and determine if parameters are passed by reference or by value
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Parameters and mutability}
\begin{block}{5 minutes challenge, solution}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> def try_to_modify(x, y, z):
...     x = 23
...     y.append(42)
...     z = [99] # new reference
...     print(x)
...     print(y)
...     print(z)
...
>>> a = 77    # immutable variable
>>> b = [99]  # mutable variable
>>> c = [28]
>>> try_to_modify(a, b, c)
23
[99, 42]
[99]
>>> print(a)
77
>>> print(b)
[99, 42]
>>> print(c)
[28]
\end{minted}
\end{block}

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Global variables}
\begin{block}{Variables declared outside the function can be referenced within the function:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [114]: x = 5

In [115]: def addx(y):
   .....:     return x + y
   .....:

In [116]: addx(10)
Out[116]: 15
\end{minted}
\end{block}
But..

\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{}
\begin{columns}[c]
\column{0.5\textwidth}
\tiny
\begin{block}{This doesn’t work:}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
x=5
In [117]: def setx(y):
   .....:     x = y
   .....:     print('x is %d' % x)
   .....:
   .....:
In [118]: setx(10)
x is 10
In [120]: x
Out[120]: 5
\end{minted}
\end{block}

\column{0.5\textwidth}
\tiny
\begin{block}{This works:}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
x=5
In [121]: def setx(y):
   .....:     global x
   .....:     x = y
   .....:     print('x is %d' % x)
   .....:
   .....:
In [122]: setx(10)
x is 10
In [123]: x
Out[123]: 10
\end{minted}
\end{block}

\end{columns}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Variable number of parameters}
Special forms of parameters:
\begin{description}
    \item[*args] any number of positional arguments packed into a tuple
\item[**kwargs]any number of keyword arguments packed into a dictionary
\end{description}
\begin{block}{}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [35]: def variable_args(*args, **kwargs):
   ....:     print 'args is', args
   ....:     print 'kwargs is', kwargs
   ....:

In [36]: variable_args('one', 'two', x=1, y=2, z=3)
args is ('one', 'two')
kwargs is {'y': 2, 'x': 1, 'z': 3}
\end{minted}
\end{block}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Docstrings}
\begin{block}{Documentation about what the function does and it’s parameters. General convention:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [67]: def funcname(params):
   ....:     """Concise one-line sentence describing the function.
   ....:
   ....:     Extended summary which can contain multiple paragraphs.
   ....:     """
   ....:     # function body
   ....:     pass
   ....:

In [68]: funcname?
Type:               function
Base Class: <type 'function'>
String Form:        <function funcname at 0xeaa0f0>
Namespace:  Interactive
File:               /home/mvelasco/Curs_Python/.../<ipython console>
Definition: funcname(params)
Docstring:
    Concise one-line sentence describing the function.

    Extended summary which can contain multiple paragraphs.
\end{minted}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Functions are objects}
  Functions are first-class objects, which means they can be:
\begin{itemize}
    \item assigned to a variable
\item an item in a list (or any collection)
\item passed as an argument to another function
\end{itemize}
\begin{block}{Example}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [38]: va = variable_args

In [39]: va('three', x=1, y=2)
args is ('three',)
kwargs is {'y': 2, 'x': 1}
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
 \begin{block}{10 min challenge: Fibonacci}
    Write a function that displays the n first terms of the Fibonacci sequence, defined by:

$u_0 = 1; u_1 = 1$

$u_{(n+2)} = u_{(n+1)} + u_n$
\end{block}
 
\begin{block}{15 minutes challenge: QuickSort}
  Implement the quicksort algorithm, as defined by wikipedia
  \end{block}
\end{frame}

\subsection{Decorators}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Decorators as function wrapper}
  \begin{block}{Function can be decorated by using the decorator syntax for functions:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
@mydecorator           # (2)
def function():        # (1)
    pass
\end{minted}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
def mydecorator(f)
    return f()
def function():                  # (1) 
    pass
function = mydecorator(function)   # (2)
\end{minted}

  \end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Decorators as function wrappers}
  \begin{block}{Example}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
def helloSolarSystem(original_function):
    def new_function():
        original_function()  # the () after "original_function" causes original_function to be called
        print("Hello, solar system!")
    return new_function
	
def helloGalaxy(original_function):
    def new_function():
        original_function()  # the () after "original_function" cause original_function to be called
        print("Hello, galaxy!")
    return new_function

@helloGalaxy
@helloSolarSystem
def hello():
    print ("Hello, world!")

# Here is where we actually *do* something!
hello()
\end{minted}
\tiny
Checkout the result of this structure
  
  \end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Debug with decorators}
\begin{block}{Just for fun}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
def debug(f):
    def my_wrapper(*args,**kwargs):
        call_string = "%s called with *args: %r, **kwargs: %r " % (f.__name__, args, kwargs)
        ret_val=f(*args,**kwargs)
        call_string+=repr(ret_val)
        if debugging:
            print call_string
        return ret_val
    return my_wrapper

@debug
def recursive(k):
    if k>1:
        return k*recursive(k-1)
    else:
        return 1

debugging=False
recursive(3)
debugging=True
recursive(3)
\end{minted}
\end{block}


\end{frame}

\subsection{Writing Scripts and New Modules}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scripts}
\begin{block}{First script}

\small
A sequence of instructions that are executed each time the script is called.

Instructions may be e.g. copied-and-pasted from the interpreter (but take care to respect indentation rules!).
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
message = "Hello how are you?"
for word in message.split():
    print word
\end{minted}


\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scripts}
\tiny
\begin{block}{in Ipython, the syntax to execute a script is \%run script.py. For example,}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: %run test.py
Hello
how
are
you?

In [2]: message
Out[2]: 'Hello how are you?'
\end{minted}

\end{block}
\tiny
\begin{block}{From de command line}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}

mvelasco->mvelasco-PC:~/Curs_Python\$ python test.py
Hello
how
are
you?
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scripts}
\begin{block}{Standalone scripts may also take command-line arguments
}
in file.py:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import sys
print sys.argv
\end{minted}
when executed
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
\$ python file.py test arguments
['file.py', 'test', 'arguments']
\end{minted}


\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Modules}
\begin{block}{Importing objects from modules}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: import os

In [2]: os
Out[2]: <module 'os' from '/usr/lib/python2.6/os.pyc'>

In [3]: os.listdir('.')
Out[3]:
['conf.py',
 'basic_types.rst',
 'control_flow.rst',
 'functions.rst',
 'python_language.rst',
 'reusing.rst',
 'file_io.rst',
 'exceptions.rst',
 'workflow.rst',
 'index.rst']
\end{minted}

\end{block}
Try to check how many functions are there in os with tab-completion and ipython
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Modules}
Alternatives to full import
\begin{block}{Import only some functions}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [4]: from os import listdir
\end{minted}

\end{block}
\begin{block}{Or a shorthand}


\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [5]: import numpy as np
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Modules}
\begin{block}{Actually, all the scientific computing tools we are going to use are modules:}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> import numpy as np # data arrays
>>> np.linspace(0, 10, 6)
array([  0.,   2.,   4.,   6.,   8.,  10.])
>>> import scipy # scientific computing
\end{minted}

\end{block}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{My own module}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
"A demo module."

def print_b():
    "Prints b."
    print 'b'
def print_a():
    "Prints a."
    print 'a'
c = 2
d = 2
\end{minted}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: import demo
In [2]: demo.print_a()
a
In [3]: demo.print_b()
b
\end{minted}
\tiny
Try this in ipython
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [4]: demo?
In [5]: who
In [6]: whos
In [7]: dir(demo)
In [8]: demo.    #tab-completion
\end{minted}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Modules}
\centering Warning:Module caching
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{‘main’ and module loading}
\begin{block}{A script and a Module}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
def print_a():
    "Prints a."
    print 'a'


if __name__ == '__main__':
    print_a()
\end{minted}


\end{block}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [12]: import demo2
In [13]: %run demo2
a
\end{minted}


\end{frame}


\subsection{Input and Output}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Input and Output}
\begin{block}{To write in a file:}
\small
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> f = open('workfile', 'w') # opens the workfile file
>>> type(f)
<type 'file'>
>>> f.write('This is a test \nand another test')
>>> f.close()
\end{minted}

\end{block}  

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Input and Output}
\begin{block}{To read from a file}
\small
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: f = open('workfile', 'r')

In [2]: s = f.read()

In [3]: print(s)
This is a test
and another test

In [4]: f.close()
\end{minted}

\end{block}  
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Input and Output}
  \begin{block}{Iterating over a file}
\small  
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [6]: f = open('workfile', 'r')

In [7]: for line in f:
...:     print line
...:
...:
This is a test
and another test
In [8]: f.close()
\end{minted}

  \end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
  \begin{block}{10 Minutes challenge}
        Write a script that reads a file with a column of numbers and calculates the min, max and sum
  \end{block}
\end{frame}

\subsection{Standard Library}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{10 minutes challenge}
Write a module that performs basic trigonometric functions using Taylor expansions
\end{block}

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{OS module: Operating system functionality}

\begin{block}{Directory and file manipulation}

Current directory:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [17]: os.getcwd()
Out[17]: '/Users/cburns/src/scipy2009/scipy_2009_tutorial/source'
\end{minted}
\normalsize
List a directory:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [31]: os.listdir(os.curdir)
Out[31]:
['.index.rst.swo',
 '.python_language.rst.swp',
 '.view_array.py.swp',
 '_static',
 '_templates',
 'basic_types.rst',
 'conf.py',
 'control_flow.rst',
 'debugging.rst',
 ...
\end{minted}



\end{block}
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{OS module: Operating system functionality}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Make a directory}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [32]: os.mkdir('junkdir')
In [33]: 'junkdir' in os.listdir(os.curdir)
Out[33]: True
\end{minted}
\end{block}
\begin{block}{Rename the directory:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [36]: os.rename('junkdir', 'foodir')
In [37]: 'junkdir' in os.listdir(os.curdir)
Out[37]: False
In [38]: 'foodir' in os.listdir(os.curdir)
Out[38]: True
In [41]: os.rmdir('foodir')
In [42]: 'foodir' in os.listdir(os.curdir)
Out[42]: False
\end{minted}


\end{block}

\column{0.5\textwidth}
\begin{block}{Delete a file:
}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [44]: fp = open('junk.txt', 'w')
In [45]: fp.close()
In [46]: 'junk.txt' in os.listdir(os.curdir)
Out[46]: True
In [47]: os.remove('junk.txt')
In [48]: 'junk.txt' in os.listdir(os.curdir)
Out[48]: False
\end{minted}

\end{block}

\end{columns}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{os.path: path manipulations}
\begin{block}{os.path provides common operations on pathnames.}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [70]: fp = open('junk.txt', 'w')
In [71]: fp.close()
In [72]: a = os.path.abspath('junk.txt')
In [73]: a
Out[73]: '/Users/cburns/src/scipy2009/scipy_2009_tutorial/source/junk.txt'
In [74]: os.path.split(a)
Out[74]: ('/Users/cburns/src/scipy2009/scipy_2009_tutorial/source','junk.txt')
In [78]: os.path.dirname(a)
Out[78]: '/Users/cburns/src/scipy2009/scipy_2009_tutorial/source'
In [79]: os.path.basename(a)
Out[79]: 'junk.txt'
In [80]: os.path.splitext(os.path.basename(a))
Out[80]: ('junk', '.txt')
In [84]: os.path.exists('junk.txt')
Out[84]: True
In [86]: os.path.isfile('junk.txt')
Out[86]: True
In [87]: os.path.isdir('junk.txt')
Out[87]: False
In [88]: os.path.expanduser('~/local')
Out[88]: '/Users/cburns/local'
In [92]: os.path.join(os.path.expanduser('~'), 'local', 'bin')
Out[92]: '/Users/cburns/local/bin'
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Other OS services}
\begin{columns}[c]
\column{0.5\textwidth}
\tiny
\begin{block}{Running an external command}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [3]: os.system('ls *.tex')
commondefs.tex	CursP_1.tex  CursP_3.tex  
CursP_4.tex     format.tex   header.tex
\end{minted}

\end{block}
\tiny
\begin{block}{Walking a directory}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [4]: for dirpath, dirnames, filenames in 
os.walk(os.curdir):
   ...:     for fp in filenames:
   ...:         print os.path.abspath(fp)
   ...:         
/home/mvelasco/Dropbox/Curs_Python/CursP_3.log
/home/mvelasco/Dropbox/Curs_Python/CursP_4.out
/home/mvelasco/Dropbox/Curs_Python/syllabus.odt
/home/mvelasco/Dropbox/Curs_Python/format.tex
/home/mvelasco/Dropbox/Curs_Python/CursP_3.pdf
/home/mvelasco/Dropbox/Curs_Python/tags
/home/mvelasco/Dropbox/Curs_Python/CursP_3.vrb

\end{minted}

\end{block}


\column{0.5\textwidth}
\tiny
\begin{block}{glob: Pattern matching on files}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [5]: import glob
In [6]: glob.glob('*.tex')
Out[6]: 
['format.tex',
 'CursP_4.tex',
 'header.tex',
 'CursP_1.tex',
 'CursP_3.tex',
 'commondefs.tex']

\end{minted}

\end{block}
\tiny
\begin{block}{ sys module: system-specific information}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [8]: import sys
In [9]: sys.platform
Out[9]: 'linux2'
In [10]: sys.version
Out[10]: '2.7.3 (default, Aug  1 2012, 05:14:39) \n[GCC 4.6.3]'
In [11]: sys.prefix
Out[11]: '/usr'
\end{minted}

\end{block}

\end{columns}
\end{frame}


\subsection{Object-Oriented Programming}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Object-oriented programming}
\begin{block}{OOP}
We are not going to use OOP in this course, but we provide some snippets of code just to know the structure of class declaration 
\end{block}

\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Object-oriented programming}
\begin{columns}[c]
\column{0.4\textwidth}
\begin{block}{Class Declaration}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def set_age(self, age):
...         self.age = age
...     def set_major(self, major):
...         self.major = major
...
>>> anna = Student('anna')
>>> anna.set_age(21)
>>> anna.set_major('physics')
\end{minted}

\end{block}

\column{0.6\textwidth}
\begin{block}{Class extension}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> class MasterStudent(Student):
...     internship = 'mandatory, from March to June'
...
>>> james = MasterStudent('james')
>>> james.internship
'mandatory, from March to June'
>>> james.set_age(23)
>>> james.age
23
\end{minted}

\end{block}

\end{columns}
\end{frame}




%\subsection{Magic Methods}

%----------------------------FRAME------------------------------------
%\begin{frame}[fragile]\frametitle{Magic Methods on class declarations}

%\end{frame}



%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------


%\section{Iterators and Generators}
%\subsection{Iterators}
%\subsection{Generators}

%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------

%\section{Creating Graphic Interfaces (optional)}


%-------------------------------------------------------------------
%---------------------------SECTION---------------------------------
%-------------------------------------------------------------------

%\section{Debugging Code (optional)}
%\subsection{Avoiding bugs}
%\subsection{Debugging Workflow}
%\subsection{Python's Debigger}
%\subsection{Debugging segfaults using gdb}

%-------------------------------------------------------------------
%---------------------------FINAL FRAME-----------------------------
%-------------------------------------------------------------------



\begin{frame}[Thank you!] 
  \begin{center}
    \centering \includegraphics[width=0.5\linewidth]{figs/question_mark}
  \end{center}
\end{frame}


\end{document}
\documentclass[colorlinks]{beamer}
  % compress
  %\documentclass[handout,xcolot=pdftex,dvipsnames,table]{beamer}
%\definecolor{mybg}{RGB}{255,255,204}
\definecolor{mybg}{RGB}{238,255,170}
\usepackage{minted}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{color}
\usepackage[utf8x]{inputenc}
%\usepackage{amsmath}
%\usepackage{beamerthemesplit}
%\usemintedstyle{trac}
\input{format.tex}
\begin{document}
\setcounter{tocdepth}{2}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection,subsection]
  \end{frame}
}
\title{ Python in a Nutshell}







\title{ Python in a Nutshell}
\subtitle
 {Part II: NumPy and Matplotlib } % (optional)

\input{header.tex} %



%----------------------------FRAME------------------------------------
\begin{frame}[plain]
   %  \titlepage
   \maketitle
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[allowframebreaks]{Contents}
  \tableofcontents
  % You might wish to add the option [pausesections]
 \note[options]{aixo son notes}
\end{frame}

%----------------------------FRAME------------------------------------
\section{Introduction to NumPy}
\subsection{Overview}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{NumPy}
\begin{block}{}

Python has built-in:
\begin{description}
    \item[containers: ]  lists (costless insertion and append), dictionaries (fast lookup)
\item[high-level number objects: ]integers, floating point

\end{description}

\end{block}
\begin{block}{}


Numpy is:
\begin{itemize}
    \item extension package to Python for multi-dimensional arrays
\item closer to hardware (efficiency)
\item designed for scientific computation (convenience)\end{itemize}
\end{block}
\begin{block}{Snippet}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import numpy as np
a = np.array([0, 1, 2, 3])
a
array([0, 1, 2, 3])
\end{minted}


\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{NumPy}
\begin{block}{For example:}
An array containing:

\begin{itemize}
    \item values of an experiment/simulation at discrete time steps
\item signal recorded by a measurement device, e.g. sound wave
\item pixels of an image, grey-level or colour
\item 3-D data measured at different X-Y-Z positions, e.g. MRI scan
\item ...

\end{itemize}
\end{block}
\tiny
\begin{block}{Memory-efficient container that provides fast numerical operations.}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: l = range(1000)
In [2]: %timeit [i**2 for i in l]
1000 loops, best of 3: 403 us per loop
In [3]: a = np.arange(1000)
In [4]: %timeit a**2
100000 loops, best of 3: 12.7 us per loop
\end{minted}

\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{NumPy}
\begin{block}{In case you need help...}
\begin{itemize}
    \item Interactive help
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
help(np.array)    
Help on built-in function array in module numpy.core.multiarray:
array(...)
    array(object, dtype=None, copy=True, order=None, subok=False, ...
...
\end{minted}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [5]: np.array?
String Form:<built-in function array>
Docstring:
array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0, ...
...
\end{minted}

\end{itemize}
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{NumPy}
\begin{block}{In case you need help...}
\begin{itemize}
\item Looking for something: 
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
np.lookfor('create array')    
Search results for 'create array'
---------------------------------
numpy.array
    Create an array.
numpy.memmap
    Create a memory-map to an array stored in a *binary* file on disk.
...
\end{minted}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
nIn [6]: p.con*?
np.concatenate
np.conj
np.conjugate
np.convolve
\end{minted}

\end{itemize}

\end{block}

\end{frame}


\subsection{Arrays}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Creating Arrays}
\begin{block}{1-D Array}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
a = np.array([0, 1, 2, 3])
a
array([0, 1, 2, 3])
a.ndim
1
a.shape
(4,)
len(a)
4
\end{minted}
\end{block}

\begin{block}{30 seconds challenge}
Is an np.array mutable?
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Creating arrays}

\begin{block}{2-D, 3-D,...}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
b = np.array([[0, 1, 2], [3, 4, 5]])    # 2 x 3 array
b
array([[0, 1, 2],
       [3, 4, 5]])
b.ndim
2
b.shape
(2, 3)
len(b)     # returns the size of the first dimension
2

c = np.array([[[1], [2]], [[3], [4]]])
c
array([[[1],
        [2]],

       [[3],
        [4]]])
c.shape
(2, 2, 1)
\end{minted}

\end{block}


\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Creating arrays}
\begin{block}{We almost never specify each element...}
\begin{itemize}
    \item Evenly spaced:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import numpy as np
a = np.arange(10) # 0 .. n-1  (!)
a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
b = np.arange(1, 9, 2) # start, end (exclusive), step
b
array([1, 3, 5, 7])
\end{minted}
\normalsize
\item or by number of points:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
c = np.linspace(0, 1, 6)   # start, end, num-points
c
array([ 0. ,  0.2,  0.4,  0.6,  0.8,  1. ])
d = np.linspace(0, 1, 5, endpoint=False)
d
array([ 0. ,  0.2,  0.4,  0.6,  0.8])
\end{minted}

\end{itemize}

\end{block}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Creating Arrays}
\begin{block}{Common arrays}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
a = np.ones((3, 3))  # reminder: (3, 3) is a tuple
a
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.]])
b = np.zeros((2, 2))
b
array([[ 0.,  0.],
       [ 0.,  0.]])
c = np.eye(3)
c
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
d = np.diag(np.array([1, 2, 3, 4]))
d
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])
\end{minted}


\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Creating Arrays}
\begin{block}{... and... more common arrays}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
a = np.random.rand(4)       # uniform in [0, 1]
a
array([ 0.95799151,  0.14222247,  0.08777354,  0.51887998])

b = np.random.randn(4)      # Gaussian
b
array([ 0.37544699, -0.11425369, -0.47616538,  1.79664113])

np.random.seed(1234)        # Setting the random seed
\end{minted}


\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{3 minutes challenge}
Create these arrays
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
[[ 1  1  1  1]
 [ 1  1  1  1]
 [ 1  1  1  2]
 [ 1  6  1  1]]
[[0. 0. 0. 0. 0.]
 [2. 0. 0. 0. 0.]
 [0. 3. 0. 0. 0.]
 [0. 0. 4. 0. 0.]
 [0. 0. 0. 5. 0.]
 [0. 0. 0. 0. 6.]]
\end{minted}
hint:Examine the docstring for diag.
\end{block}
\begin{block}{2 minutes challenge}
Skim through the documentation for np.tile, and use this function to construct the array:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
[[4 3 4 3 4 3]
 [2 1 2 1 2 1]
 [4 3 4 3 4 3]
 [2 1 2 1 2 1]]
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Basic Data Types}
\begin{block}{Check the difference}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
a = np.array([1, 2, 3])
a.dtype
dtype('int64')

b = np.array([1., 2., 3.])
b.dtype
dtype('float64')
\end{minted}


\end{block}
Different data-types allow us to store data more compactly in memory, but most of the time we simply work with floating point numbers. Note that, in the example above, NumPy auto-detects the data-type from the input.
\begin{block}{explicitly specify which data-type you want:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
c = np.array([1, 2, 3], dtype=float)
c.dtype
dtype('float64')
\end{minted}


\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Data Types}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Complex}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
d = np.array([1+2j, 3+4j, 5+6*1j])
d.dtype
dtype('complex128')
\end{minted}

\end{block}
\begin{block}{Bool}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
e = np.array([True, False, False, True])
e.dtype
dtype('bool')
\end{minted}

\end{block}

\column{0.5\textwidth}
\begin{block}{Strings}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
f = np.array(['Bonjour', 'Hello', 'Hallo',])
f.dtype    
dtype('S7') # <--- strings containing max. 7 letters
\end{minted}

\end{block}
\begin{block}{and more..}
int32/int64...

\end{block}

\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Array representation}
\begin{block}{Start by launching IPython in pylab mode:}
\begin{verbatim}
    $ ipython --pylab
\end{verbatim}
\end{block}
\begin{block}{Matplotlib is a 2D plotting package. We can import its functions as below:}

\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [0]: import matplotlib.pyplot as plt 
\end{minted}

\end{block}


\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{1D plotting }
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0, 3, 20)
y = np.linspace(0, 9, 20)
plt.plot(x, y)       # line plot    
plt.plot(x, y, 'o')  # dot plot    
@
%-------------------------------END CODE
this code is under CLI just to check the difference
\end{block}

\column{0.5\textwidth}
\begin{block}{Result}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
plt.show()
@
%-------------------------------END CODE
\end{block}
\end{columns}
\end{frame}



%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Array representation}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{2D arrays (such as images}
%-------------------------------CODE
\tiny
<<term=TRUE,echo=TRUE,fig=FALSE>>=
import numpy as np
import matplotlib.pyplot as plt
image = np.random.rand(30, 30)
plt.imshow(image, cmap=plt.cm.hot)    
plt.colorbar()    
@
%-------------------------------END CODE
\end{block}

\column{0.5\textwidth}
%-------------------------------CODE

<<term=TRUE,echo=FALSE,fig=TRUE>>=
plt.show()
@
%-------------------------------END CODE
     
\end{columns}
\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Array representation}
\begin{block}{3D plotting}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [58]: from mayavi import mlab
In [61]: mlab.surf(image)
Out[61]: <enthought.mayavi.modules.surface.Surface object at ...>
In [62]: mlab.axes()
Out[62]: <enthought.mayavi.modules.axes.Axes object at ...>
\end{minted}


\end{block}
\begin{center}
    
    \includegraphics[scale=0.3]{figs/surf1.png}
\end{center}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{5 minutes challenge}
Plot a sine 1D signal with frequency $10\frac{\text{rad}}{\text{s}}$ sampled everu $0.01$s during $10$s.



\tiny HINT:Use np.sin 
\end{block}
\begin{block}{1 minute challenge}
Plot the previous signal subsampled, one sample every $0.5$s 
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Indexing and slicing}
\begin{block}{Indexing}

The items of an array can be accessed and assigned to the same way as other Python sequences (e.g. lists)
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[0], a[2], a[-1]
(0, 2, 9)
\end{minted}
\normalsize
For multidimensional arrays, indexes are tuples of integers:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.diag(np.arange(3))
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 2]])
>>> a[1, 1]
1
>>> a[2, 1] = 10 # third line, second column
>>> a
array([[ 0,  0,  0],
       [ 0,  1,  0],
       [ 0, 10,  2]])
>>> a[1]
array([0, 1, 0])
\end{minted}


\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Indexing and slicing}
\begin{block}{Slicing}
Slicing Arrays, like other Python sequences can also be sliced:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[2:9:3] # [start:end:step]
array([2, 5, 8])
\end{minted}
\normalsize
Note that the last index is not included!
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a[:4]
array([0, 1, 2, 3])
\end{minted}
\normalsize
All three slice components are not required: by default, start is 0, end is the last and step is 1:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a[1:3]
array([1, 2])
>>> a[::2]
array([0, 2, 4, 6, 8])
>>> a[3:]
array([3, 4, 5, 6, 7, 8, 9])
\end{minted}


\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/slicing.pdf}
}

\begin{frame}[fragile]\frametitle{Indexing and slicing}
\vspace{-4cm}
\begin{block}{Small summary}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
a=np.array([np.arange(6)+10*i for i in numpy.arange(6)])
\end{minted}
\end{block}

\end{frame}
}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Copies and views}
A slicing operation creates a view on the original array, which is just a way of accessing array data. Thus the original array is not copied in memory.

\begin{block}{1 minute challenge}
Check mutability when accessing an array from a sliced view

\end{block}

\begin{block}{Use .copy() to copy a NumPy array}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(10)
>>> b = a[::2].copy()  # force a copy
>>> b[0] = 12
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
\end{minted}

\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Copies and views}
\begin{block}{Warning}
This behavior can be surprising at first sight... but it allows to save both memory and time.

As a result, a matrix cannot be made symmetric in-place:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.ones((100, 100))
>>> a += a.T
>>> a
array([[ 2.,  2.,  2., ...,  2.,  2.,  2.],
       [ 2.,  2.,  2., ...,  2.,  2.,  2.],
       [ 2.,  2.,  2., ...,  2.,  2.,  2.],
       ...,
       [ 3.,  3.,  3., ...,  2.,  2.,  2.],
       [ 3.,  3.,  3., ...,  2.,  2.,  2.],
       [ 3.,  3.,  3., ...,  2.,  2.,  2.]])
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{5 minutes challenge}
Construct an array containing the prime numbers between 1 and 100
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Masks}
\begin{block}{Using boolean masks}

\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> np.random.seed(3)
>>> a = np.random.random_integers(0, 20, 15)
>>> a
array([10,  3,  8,  0, 19, 10, 11,  9, 10,  6,  0, 20, 12,  7, 14])
>>> (a % 3 == 0)
array([False,  True, False,  True, False, False, False,  True, False,
        True,  True, False,  True, False, False], dtype=bool)
>>> mask = (a % 3 == 0)
>>> extract_from_a = a[mask] # or,  a[a%3==0]
>>> extract_from_a           # extract a sub-array with the mask
array([ 3,  0,  9,  6,  0, 12])
\end{minted}
\normalsize
Indexing with a mask can be very useful to assign a new value to a sub-array:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a[a % 3 == 0] = -1
>>> a
array([10, -1,  8, -1, 19, 10, 11, -1, 10, -1, -1, 20, -1,  7, 14])
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Indexing... more}
\begin{block}{Indexing with an array of int}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
\end{minted}
Indexing can be done with an array of integers, where the same index is repeated several time:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a[[2, 3, 2, 4, 2]]  # note: [2, 3, 2, 4, 2] is a Python list
array([2, 3, 2, 4, 2])
\end{minted}
New values can be assigned with this kind of indexing:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a[[9, 7]] = -10
>>> a
array([  0,   1,   2,   3,   4,   5,   6, -10,   8, -10])
\end{minted}
When a new array is created by indexing with an array of integers, the new array has the same shape than the array of integers:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(10)
>>> idx = np.array([[3, 4], [9, 7]])
>>> a[idx]
array([[3, 4],
       [9, 7]])
>>> b = np.arange(10)
\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{1 minute challenge}
Check whenever the indexing with int is a view or a copy of the original array
\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
{
\usebackgroundtemplate{
  \includegraphics[width=\paperwidth,height=\paperheight]{figs/slicing_int.pdf}
}

\begin{frame}[fragile]\frametitle{Fancy Indexing }
\vspace{-4cm}
\begin{block}{Small summary}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
a=np.array([np.arange(6)+10*i for i in numpy.arange(6)])
\end{minted}
\end{block}

\end{frame}
}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Indexing}

\begin{block}{Adding axes while indexing}



Indexing with the np.newaxis object allows us to add an axis to an array:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> z = np.array([1, 2, 3])
>>> z
array([1, 2, 3])
>>> z[:, np.newaxis]
array([[1],
       [2],
       [3]])
>>> z[np.newaxis, :]
array([[1, 2, 3]])

\end{minted}
\end{block}
\end{frame}


\subsection{Operating with Arrays}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Elementwise operations}
With scalars:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> a = np.array([1, 2, 3, 4])
>>> a + 1
array([2, 3, 4, 5])
>>> 2**a
array([ 2,  4,  8, 16])
\end{minted}
\normalsize
All arithmetic operates elementwise:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> b = np.ones(4) + 1
>>> a - b
array([-1.,  0.,  1.,  2.])
>>> a * b
array([ 2.,  4.,  6.,  8.])
>>> j = np.arange(5)
>>> 2**(j + 1) - j
array([ 2,  3,  6, 13, 28])
\end{minted}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Warning}


Array multiplication is not matrix multiplication:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> c = np.ones((3, 3))
>>> c * c                   # NOT matrix multiplication!
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.]])

\end{minted}
\end{block}
\begin{block}{Use .dot()}


Note Matrix multiplication:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> c.dot(c)
array([[ 3.,  3.,  3.],
       [ 3.,  3.,  3.],
       [ 3.,  3.,  3.]])

\end{minted}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{More operations}

\tiny
Comparisons:
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> a = np.array([1, 2, 3, 4])
>>> b = np.array([4, 2, 2, 4])
>>> a == b
array([False,  True, False,  True], dtype=bool)
>>> a > b
array([False, False,  True, False], dtype=bool)
\end{minted}

Logical operations:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> a = np.array([1, 1, 0, 0], dtype=bool)
>>> b = np.array([1, 0, 1, 0], dtype=bool)
>>> np.logical_or(a, b)
array([ True,  True,  True, False], dtype=bool)
>>> np.logical_and(a, b)
array([ True, False, False, False], dtype=bool)
\end{minted}
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{More operations}
Shape mismatches:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> a + np.array([1, 2])    
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: shape mismatch: objects cannot be broadcast to a single shape
\end{minted}
\normalsize
'Broadcast'? We'll return to that later.
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{3 minutes challenge}
Generate arrays [2**0, 2**1, 2**2, 2**3, 2**4] 

and $a_j = 2^{3*j} - j$
\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Basic reductions}


Computing sums:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}


>>> x = np.array([1, 2, 3, 4])
>>> np.sum(x)
10
>>> x.sum()
10

\end{minted}
\normalsize
Sum by rows and by columns:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> x = np.array([[1, 1], [2, 2]])
>>> x
array([[1, 1],
       [2, 2]])
>>> x.sum(axis=0)   # columns (first dimension)
array([3, 3])
>>> x[:, 0].sum(), x[:, 1].sum()
(3, 3)
>>> x.sum(axis=1)   # rows (second dimension)
array([2, 4])
>>> x[0, :].sum(), x[1, :].sum()
(2, 4)
\end{minted}
\end{block}
\column{0.5\textwidth}
\vspace{-3cm}
  \includegraphics[scale=0.6]{figs/reductions.png}
\end{columns}
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Statistics}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}

>>> x = np.array([1, 2, 3, 1])
>>> y = np.array([[1, 2, 3], [5, 6, 1]])
>>> x.mean()
1.75
>>> np.median(x)
1.5
>>> np.median(y, axis=-1) # last axis
array([ 2.,  5.])
\end{minted}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> x.std()  # full population standard dev.
0.82915619758884995
\end{minted}

\end{block}

\begin{block}{Logical operations}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> np.all([True, True, False])
False
>>> np.any([True, True, False])
True
\end{minted}
\end{block}

\column{0.5\textwidth}
\begin{block}{Extrema}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> x = np.array([1, 3, 2])
>>> x.min()
1
>>> x.max()
3
\end{minted}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> x.argmin()  # index of minimum
0
>>> x.argmax()  # index of maximum
1
\end{minted}
\end{block}



\begin{block}{Note: very usefull}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.zeros((100, 100))
>>> np.any(a != 0)
False
>>> np.all(a == a)
True
\end{minted}
\end{block}


\end{columns}
\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Guided exemple}
\begin{columns}[c]
\column{0.6\textwidth}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
import numpy as np
import matplotlib.pyplot as plt
# We can first plot the data:
data = np.loadtxt('challenges/populations.txt')
year, hares, lynxes, carrots = data.T  # trick: columns to variables
plt.plot(year, hares, year, lynxes, year, carrots)
plt.legend(('Hare', 'Lynx', 'Carrot'), loc=(1.05, 0.5))
# The mean populations over time:
populations = data[:,1:]
print populations.mean(axis=0)
# [ 34080.95238095,  20166.66666667,  42400.        ]
# The sample standard deviations:
print populations.std(axis=0, ddof=1)
# [ 21413.98185877,  16655.99991995,   3404.55577132]
# Which species has the highest population each year?
print np.argmax(populations, axis=1)
# [2, 2, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 2, 2, 2, 2, 2]
@
%-------------------------------END CODE
\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Guided exemple}
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
import numpy as np
import matplotlib.pyplot as plt
n_stories = 1000 # number of walkers
t_max = 200      # time during which we follow the walker
# We randomly choose all the steps 1 or -1 of the walk
t = np.arange(t_max)
steps = 2 * np.random.random_integers(0, 1, (n_stories, t_max)) - 1
print np.unique(steps) # Verification: all steps are 1 or -1
# [-1,  1]
# We build the walks by summing steps along the time
positions = np.cumsum(steps, axis=1) # axis = 1: dimension of time
sq_distance = positions**2
# We get the mean in the axis of the stories
mean_sq_distance = np.mean(sq_distance, axis=0)
# Plot the results:
plt.figure(figsize=(4, 3))
plt.plot(t, np.sqrt(mean_sq_distance), 'g.', t, np.sqrt(t), 'y-')
plt.xlabel(r"$t$")
plt.ylabel(r"$\sqrt{\langle (\delta x)^2 \rangle}$")
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{}
\begin{columns}[c]
\column{0.7\textwidth}

%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
plt.show()
@
%-------------------------------END CODE
\column{0.3\textwidth}

\end{columns}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Broadcasting}
\includegraphics[scale=0.25]{figs/numpy_broadcasting.png}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{1 minute challenge}
Verify that broadcasting works as specified
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Broadcasting example}
Let’s construct an array of distances (in miles) between cities of Europe.
\tiny
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=

mileposts = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544,1913, 2448])
distance_array = np.abs(mileposts - mileposts[:, np.newaxis])
distance_array
@
%-------------------------------END CODE

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Array shape manipulation}
\tiny
Flattening
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> a.ravel()
array([1, 2, 3, 4, 5, 6])
>>> a.T
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> a.T.ravel()
array([1, 4, 2, 5, 3, 6])
\end{minted}

Reshaping
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a.shape
(2, 3)
>>> b = a.ravel()
>>> b.reshape((2, 3))
array([[1, 2, 3],
       [4, 5, 6]])
\end{minted}


\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example of use for Phisicists}
\begin{block}{Block matrices and vectors (and tensors)}
Vector space: quantum level $\otimes$ spin
\[
\check{\psi}=\left(\begin{matrix}\hat{\psi}_1 \\ \hat{\psi}_2\end{matrix}\right),\,\,\,\hat{\psi}_1=\left(\begin{matrix}\psi_{1\uparrow} \\ \psi_{1\downarrow}\end{matrix}\right),\,\,\,\hat{\psi}_2=\left(\begin{matrix}\psi_{2\uparrow} \\ \psi_{2\downarrow}\end{matrix}\right)
\]
In short: for block matrices and vectors, it can be useful to preserve the block structure.
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> psi = np.zeros((2, 2))   # dimensions: level, spin
>>> psi[0, 1] # <-- psi_{1,downarrow}
0.0
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example of use for Phisicists}
\begin{block}{Block matrices and vectors (and tensors)}
Linear operators on such block vectors have similar block structure:
\small
\[
\check{H}=\left(\begin{matrix}\hat{h}_{11} & \hat{V} \\ \hat{V}^\dagger & \hat{h}_{22} \end{matrix}\right),\,\,\check{h}_{11}=\left(\begin{matrix}\epsilon_{1\uparrow} & 0 \\ 0 & \epsilon_{1\downarrow} \end{matrix}\right)
\]
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> H = np.zeros((2, 2, 2, 2)) # dimensions: level1, level2, spin1, spin2
>>> h_11 = H[0,0,:,:]
>>> V = H[0,1]
\end{minted}
\normalsize
Doing the matrix product: get rid of the block structure, do the 4x4 matrix product, then put it back
\small
\[
\check{H}\check{\psi}
\]
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> def mdot(operator, psi):
...     return operator.transpose(0, 2, 1, 3).reshape(4, 4).dot(
...                psi.reshape(4)).reshape(2, 2)
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Sorting data}
Sorting along an axis:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([[4, 3, 5], [1, 2, 1]])
>>> b = np.sort(a, axis=1)
>>> b
array([[3, 4, 5],
       [1, 1, 2]])
\end{minted}

\normalsize
In-place sort:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a.sort(axis=1)
>>> a
array([[3, 4, 5],
       [1, 1, 2]])
\end{minted}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Numerical Operations}
\begin{block}{Getting indices of the sort}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([4, 3, 1, 2])
>>> j = np.argsort(a)
>>> j
array([2, 3, 1, 0])
>>> a[j]
array([1, 2, 3, 4])
\end{minted}
\end{block}
\begin{block}{Also getting indices of min and max}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([4, 3, 1, 2])
>>> j_max = np.argmax(a)
>>> j_min = np.argmin(a)
>>> j_max, j_min
(0, 2)
\end{minted}



\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{5 minutes multy-challenge}
\begin{enumerate}
    \item Form the 2-D array (without typing it in explicitly):
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
1  6 11
2  7 12
3  8 13
4  9 14
5 10 15
\end{minted}
\normalsize
and generate a new array containing its 2nd and 4th rows.
\item Divide each column of the array:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.arange(25).reshape(5, 5)
\end{minted}

\normalsize
elementwise with the array b = np.array([1., 5, 10, 15, 20]). (Hint: np.newaxis).

\end{enumerate}

\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{Worked challenge}
From Lena picture get these modifications

\centering
\includegraphics[scale=0.5]{figs/lenas.png}
\end{block}
\begin{block}{Lena picture}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> from scipy import misc
>>> lena = misc.lena()
\end{minted}

\end{block}




\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Solution to Lena}
\begin{block}{First image}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [3]: import pylab as plt
In [4]: lena = misc.lena()
In [5]: plt.imshow(lena)
\end{minted}

\end{block}
\pause
\begin{block}{Second image}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [6]: plt.imshow(lena, cmap=plt.cm.gray)
\end{minted}

\end{block}
\pause
\begin{block}{Third image}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [9]: crop_lena = lena[30:-30,30:-30]
\end{minted}

\end{block}


\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Solution to Lena}


\begin{block}{Last image}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [15]: y, x = np.ogrid[0:512,0:512] # x and y indices of pixels
In [16]: y.shape, x.shape
Out[16]: ((512, 1), (1, 512))
In [17]: centerx, centery = (256, 256) # center of the image
In [18]: mask = ((y - centery)**2 + (x - centerx)**2) > 230**2 # circle
In [19]: lena[mask] = 0
In [20]: plt.imshow(lena)
\end{minted}

\end{block}

\end{frame}



\subsection{Advanced Arrays (ndarrays)}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{More elaborated arrays}
\begin{block}{Casting}
“Bigger” type wins in mixed-type operations:
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> np.array([1, 2, 3]) + 1.5
array([ 2.5,  3.5,  4.5])
\end{minted}

\end{block}
\begin{block}{Assignment never changes the type!}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([1, 2, 3])
>>> a.dtype
dtype('int64')
>>> a[0] = 1.9     # <-- float is truncated to integer
>>> a
array([1, 2, 3])
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{More elaborated arrays}
\begin{block}{Forced casts:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([1.7, 1.2, 1.6])
>>> b = a.astype(int)  # <-- truncates to integer
>>> b
array([1, 1, 1])
\end{minted}

\end{block}
\begin{block}{Rounding:}


\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> a = np.array([1.2, 1.5, 1.6, 2.5, 3.5, 4.5])
>>> b = np.around(a)
>>> b                    # still floating-point
array([ 1., 2., 2., 2., 4., 4.])
>>> c = np.around(a).astype(int)
>>> c
array([ 1, 2, 2, 2, 4, 4])
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{ Structured data types}
\begin{block}{Sensor example}
\begin{itemize}
    \item sensor code (4 character string)	 
\item position (float)	 
\item value (float)
\end{itemize}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> samples = np.zeros((6,), dtype=[('sensor_code', 'S4'),
...                                 ('position', float), ('value', float)])
>>> samples.ndim
1
>>> samples.shape
(6,)
>>> samples.dtype.names
('sensor_code', 'position', 'value')
\end{minted}

\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Structured data types}
\begin{block}{Assignment}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> samples[:] = [('ALFA',   1, 0.37), ('BETA', 1, 0.11), ('TAU', 1,   0.13),
...               ('ALFA', 1.5, 0.37), ('ALFA', 3, 0.11), ('TAU', 1.2, 0.13)]
>>> samples
array([('ALFA', 1.0, 0.37), ('BETA', 1.0, 0.11), ('TAU', 1.0, 0.13),
       ('ALFA', 1.5, 0.37), ('ALFA', 3.0, 0.11), ('TAU', 1.2, 0.13)],
      dtype=[('sensor_code', '|S4'), ('position', '<f8'), ('value', '<f8')])
\end{minted}
\end{block}
\begin{block}{Field access works by indexing with field names:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> samples['sensor_code']
array(['ALFA', 'BETA', 'TAU', 'ALFA', 'ALFA', 'TAU'],
      dtype='|S4')
>>> samples['value']
array([ 0.37,  0.11,  0.13,  0.37,  0.11,  0.13])
>>> samples[0]
('ALFA', 1.0, 0.37)

>>> samples[0]['sensor_code'] = 'TAU'
>>> samples[0]
('TAU', 1.0, 0.37)
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Structured Data Types}
\begin{block}{Multiple fields at once:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> samples[['position', 'value']]
array([(1.0, 0.37), (1.0, 0.11), (1.0, 0.13), (1.5, 0.37), (3.0, 0.11),
       (1.2, 0.13)],
      dtype=[('position', '<f8'), ('value', '<f8')])
\end{minted}

\end{block}
\begin{block}{Fancy indexing works, as usual:}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> samples[samples['sensor_code'] == 'ALFA']
array([('ALFA', 1.5, 0.37), ('ALFA', 3.0, 0.11)],
      dtype=[('sensor_code', '|S4'), ('position', '<f8'), ('value', '<f8')])
\end{minted}

\end{block}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Under the Hood}
\includegraphics[scale=0.6]{figs/ndarray.png}
\end{frame}
\subsection{Advanced Operations}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Advanced Operations}
\begin{block}{Polinomials}
Numpy also contains polynomials in different bases, for instance $3x^2+2x-1$
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> p = np.poly1d([3, 2, -1])
>>> p(0)
-1
>>> p.roots
array([-1.        ,  0.33333333])
>>> p.order
2
\end{minted}

\end{block}
\begin{block}{Fitting...}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> x = np.linspace(0, 1, 20)
>>> y = np.cos(x) + 0.3*np.random.rand(20)
>>> p = np.poly1d(np.polyfit(x, y, 3))
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Advanced Operations}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{fitting result}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> t = np.linspace(0, 1, 200)
>>> plt.plot(x, y, 'o', t, p(t), '-') 
\end{minted}

\end{block}

\column{0.5\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 1, 20)
y = np.cos(x) + 0.3*np.random.rand(20)
p = np.poly1d(np.polyfit(x, y, 3))

t = np.linspace(0, 1, 200)
plt.plot(x, y, 'o', t, p(t), '-')
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{More Polinomials}
\begin{block}{Chebyshev}
$3x^2+2x-1$
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> p = np.polynomial.Polynomial([-1, 2, 3]) # coefs in different order!
>>> p(0)
-1.0
>>> p.roots()
array([-1.        ,  0.33333333])
>>> p.degree()  # In general polynomials do not always expose 'order'
2
\end{minted}

\end{block}

\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Example}
\begin{columns}[c]
\column{0.5\textwidth}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
>>> x = np.linspace(-1, 1, 2000)
>>> y = np.cos(x) + 0.3*np.random.rand(2000)
>>> p = np.polynomial.Chebyshev.fit(x, y, 90)
>>> t = np.linspace(-1, 1, 200)
>>> plt.plot(x, y, 'r.')   
[<matplotlib.lines.Line2D object at ...>]
>>> plt.plot(t, p(t), 'k-', lw=3)   
[<matplotlib.lines.Line2D object at ...>]
\end{minted}

\column{0.5\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
x = np.linspace(-1, 1, 2000)
y = np.cos(x) + 0.3*np.random.rand(2000)
p = np.polynomial.Chebyshev.fit(x, y, 90)
t = np.linspace(-1, 1, 200)
plt.plot(x, y, 'r.')   
plt.plot(t, p(t), 'k-', lw=3)   
@
%-------------------------------END CODE
\end{columns}
\end{frame}



\section{Matplotlib}

\subsection{Introduction}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Matplotlib Vs Pylab}
\begin{block}{Matplotlib}
\tiny
matplotlib is probably the single most used Python package for 2D-graphics
\end{block}
\begin{block}{Pylab}
\tiny
pylab provides a procedural interface to the matplotlib object-oriented plotting library. It is modeled closely after Matlab(TM). Therefore, the majority of plotting commands in pylab have Matlab(TM) analogs with similar arguments
\end{block}
\begin{block}{Conclusion}
\tiny
Learn Pylab
\end{block}
\begin{block}{How to bring pylab to work}
\tiny
\begin{itemize}
    \item Fom any editor import it
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
from pylab import *
\end{minted}
\item start iPython with pylab
\begin{verbatim}
    $ ipython --pylab
\end{verbatim}
\end{itemize}

\end{block}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Process}
\begin{block}{Learn by example}
To show how it works lets make an evolutive graphic
\end{block}

\end{frame}



\subsection{Figures and Subplots}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Simple plot}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{Create data and plot it}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import pylab as pl
import numpy as np

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

pl.plot(X, C)
pl.plot(X, S)

pl.show()
\end{minted}

\end{block}

\column{0.4\textwidth}

%------------------------------CODE
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)
pl.plot(X, C)
pl.plot(X,S)
@
%-------------------------------END CODE
\end{columns}
\end{frame}
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Instantiating defaults}
\begin{columns}[c]
\column{0.7\textwidth}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import pylab as pl
import numpy as np
# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)
# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)
X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)
# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")
# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")
# Set x limits
pl.xlim(-4.0, 4.0)
# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))
# Set y limits
pl.ylim(-1.0, 1.0)
# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))
# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)
# Show result on screen
pl.show()
\end{minted}

\column{0.3\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen
@
%-------------------------------END CODE
\end{columns}
\end{frame}
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Changing colors and line widths}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{First step}
\tiny
the cosine in blue and the sine in red and a slighty thicker line for both of them. We’ll also slightly alter the figure size to make it more horizontal.
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")

@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Setting limits}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{Second step}
\tiny
Lets adjust a little bit the figure limits
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
@
%-------------------------------END CODE
\end{columns}
\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Setting tickss}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{Third step}
\tiny
Change figure tiks
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])

@
%-------------------------------END CODE
\end{columns}
\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Setting tick labels}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{Forth step}
\tiny
Change figure tiks' labels
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],
[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])

pl.yticks([-1, 0, +1],
          [r'$-1$', r'$0$', r'$+1$'])
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])
@
%-------------------------------END CODE
\end{columns}
\end{frame}



%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Moving spines}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{Forth step}
\tiny
Change axis positions
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
ax = pl.gca()  # gca stands for 'get current axis'
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('data',0))
ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('data',0))
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
ax = pl.gca()  # gca stands for 'get current axis'
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('data',0))
ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('data',0))
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])

@
%-------------------------------END CODE
\end{columns}
\end{frame}




%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Adding a legend}
\begin{columns}[c]
\column{0.6\textwidth}
\begin{block}{Going on...}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-",
        label="cosine")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-",
        label="sine")

pl.legend(loc='upper left')
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])
ax = pl.gca()  # gca stands for 'get current axis'
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('data',0))
ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('data',0))
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-", label="cosine")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-", label="sine")

pl.legend(loc='upper left')
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])

@
%-------------------------------END CODE
\end{columns}
\end{frame}






%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Annotate some points}
\begin{columns}[c]
\column{0.7\textwidth}
\begin{block}{Going on...}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
t = 2 * np.pi / 3
pl.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5,
         linestyle="--")
pl.scatter([t, ], [np.cos(t), ], 50, color='blue')

pl.annotate(r'$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$',
            xy=(t, np.sin(t)), xycoords='data',
            xytext=(+10, +30), textcoords='offset points', 
            fontsize=16,arrowprops=dict(arrowstyle="->", 
            connectionstyle="arc3,rad=.2"))

pl.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5,
            linestyle="--")
pl.scatter([t, ],[np.sin(t), ], 50, color='red')

pl.annotate(r'$cos(\frac{2\pi}{3})=-\frac{1}{2}$',
            xy=(t, np.cos(t)), xycoords='data',
            xytext=(-90, -50), textcoords='offset points',
            fontsize=16,arrowprops=dict(arrowstyle="->", 
            connectionstyle="arc3,rad=.2"))
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])
ax = pl.gca()  # gca stands for 'get current axis'
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('data',0))
ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('data',0))
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-", label="cosine")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-", label="sine")

pl.legend(loc='upper left')
t = 2 * np.pi / 3
pl.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5, linestyle="--")
pl.scatter([t, ], [np.cos(t), ], 50, color='blue')

pl.annotate(r'$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$',xy=(t, np.sin(t)), xycoords='data',xytext=(+10, +30), textcoords='offset points', fontsize=16,arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))

pl.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5, linestyle="--")
pl.scatter([t, ],[np.sin(t), ], 50, color='red')

pl.annotate(r'$cos(\frac{2\pi}{3})=-\frac{1}{2}$',xy=(t, np.cos(t)), xycoords='data',xytext=(-90, -50), textcoords='offset points', fontsize=16,arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])

@
%-------------------------------END CODE
\end{columns}
\end{frame}







%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Finally...}
\begin{columns}[c]
\column{0.7\textwidth}
\begin{block}{The last detail}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
for label in ax.get_xticklabels() + ax.get_yticklabels():
    label.set_fontsize(16)
    label.set_bbox(dict(facecolor='white', edgecolor='None', 
    alpha=0.65))
...
\end{minted}

\end{block}

\column{0.4\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
import pylab as pl
import numpy as np

# Create a figure of size 8x6 points, 80 dots per inch
pl.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
pl.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
pl.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
pl.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
pl.xlim(-4.0, 4.0)

# Set x ticks
pl.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
pl.ylim(-1.0, 1.0)

# Set y ticks
pl.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# savefig("exercice_2.png", dpi=72)

# Show result on screen

pl.figure(figsize=(10, 6), dpi=80)
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-")
pl.xlim(X.min() * 1.1, X.max() * 1.1)
pl.ylim(C.min() * 1.1, C.max() * 1.1)
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])
ax = pl.gca()  # gca stands for 'get current axis'
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('data',0))
ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('data',0))
pl.plot(X, C, color="blue", linewidth=2.5, linestyle="-", label="cosine")
pl.plot(X, S, color="red",  linewidth=2.5, linestyle="-", label="sine")

pl.legend(loc='upper left')
t = 2 * np.pi / 3
pl.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5, linestyle="--")
pl.scatter([t, ], [np.cos(t), ], 50, color='blue')

pl.annotate(r'$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$',xy=(t, np.sin(t)), xycoords='data',xytext=(+10, +30), textcoords='offset points', fontsize=16,arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))

pl.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5, linestyle="--")
pl.scatter([t, ],[np.sin(t), ], 50, color='red')

pl.annotate(r'$cos(\frac{2\pi}{3})=-\frac{1}{2}$',xy=(t, np.cos(t)), xycoords='data',xytext=(-90, -50), textcoords='offset points', fontsize=16,arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
pl.yticks([-1, 0, +1])
pl.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
pl.yticks([-1, 0, +1],[r'$-1$', r'$0$', r'$+1$'])

for label in ax.get_xticklabels() + ax.get_yticklabels():
    label.set_fontsize(16)
    label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.7))

@
%-------------------------------END CODE
\end{columns}
\end{frame}





\subsection{Axes and further control of figures}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Creating figures}
\begin{block}{Parameters}
\begin{description}
    \item[num] number of figure, start by 1!!!
\item [figsize]	figure.figsize,figure size in in inches (width, height)
\item [dpi] figure.dpi ,resolution in dots per inch
\item [facecolor] figure.facecolor, color of the drawing background
\item [edgecolor] figure.edgecolor, color of edge around the drawing background
\item [frameon] True, draw figure frame or not 
\end{description}
\end{block}

\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Subplots}
\begin{columns}[c]
\column{0.5\textwidth}
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
pl.figure(figsize=(6, 4))
pl.subplot(2, 2, 1)
pl.xticks(())
pl.yticks(())
pl.text(0.5, 0.5, 'subplot(2,2,1)', ha='center',
     va='center',size=20, alpha=.5)

pl.subplot(2, 2, 2)
pl.xticks(())
pl.yticks(())
pl.text(0.5, 0.5, 'subplot(2,2,2)', ha='center', 
     va='center', size=20, alpha=.5)

pl.subplot(2, 2, 3)
pl.xticks(())
pl.yticks(())

pl.text(0.5, 0.5, 'subplot(2,2,3)', ha='center', 
    va='center', size=20, alpha=.5)

pl.subplot(2, 2, 4)
pl.xticks(())
pl.yticks(())
pl.text(0.5, 0.5, 'subplot(2,2,4)', ha='center', 
        va='center', size=20, alpha=.5)

pl.tight_layout()
pl.show()
\end{minted}

\column{0.5\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=FALSE,fig=TRUE>>=
pl.figure(figsize=(6, 4))
pl.subplot(2, 2, 1)
pl.xticks(())
pl.yticks(())
pl.text(0.5, 0.5, 'subplot(2,2,1)', ha='center', va='center',
        size=20, alpha=.5)

pl.subplot(2, 2, 2)
pl.xticks(())
pl.yticks(())
pl.text(0.5, 0.5, 'subplot(2,2,2)', ha='center', va='center',
        size=20, alpha=.5)

pl.subplot(2, 2, 3)
pl.xticks(())
pl.yticks(())

pl.text(0.5, 0.5, 'subplot(2,2,3)', ha='center', va='center',
        size=20, alpha=.5)

pl.subplot(2, 2, 4)
pl.xticks(())
pl.yticks(())
pl.text(0.5, 0.5, 'subplot(2,2,4)', ha='center', va='center',
        size=20, alpha=.5)

pl.tight_layout()
@
%-------------------------------END CODE
\end{columns}
\end{frame}


%-------------------------------------------------------------------
%---------------------------FINAL FRAME-----------------------------
%-------------------------------------------------------------------



\begin{frame}[Thank you!] 
  \begin{center}
    \centering \includegraphics[width=0.5\linewidth]{figs/question_mark}
  \end{center}
\end{frame}


\end{document}
\documentclass[10pt,colorlinks]{beamer}
  % compress
  %\documentclass[handout,xcolot=pdftex,dvipsnames,table]{beamer}
\definecolor{mybg}{RGB}{255,255,204}
\usepackage{minted}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}


 \usepackage{beamerthemesplit}

%\usemintedstyle{trac}
\input{format.tex}





% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer,allowframebreaks>{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}



\title{ Python in a Nutshell}
\subtitle
{Part III: Introduction to SciPy and SimPy} % (optional)

\input{header.tex} %

\begin{document}


\begin{frame}[plain]
   %  \titlepage
   \maketitle
\end{frame}


\begin{frame}[allowframebreaks]{Contents}
  \tableofcontents
  % You might wish to add the option [pausesections]
 \note[options]{aixo son notes}
\end{frame}

\section{Introduction}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{SciPy}
\begin{figure}[!htb]
    \includegraphics[width=\textwidth]{figs/nicetry}
\end{figure}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scipy}
Up to now:
\begin{description}
    \item<1->[python]  A general purpose programming language. It is interpreted and dynamically typed and is very suited for interactive work and quick prototyping, while being powerful enough to write large applications in.
    \item<2->[Numpy] A language extension that defines the numerical array and matrix type and basic operations on them.
    \item<3->[matplotlib] A language extension to facilitate plotting. 
    \item<4->[Scipy] Scipy is another language extension that uses numpy to do advanced math, signal processing, optimization, statistics and much more.

\end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{History of SciPy}
  \begin{description}
    \item[1995] first, there was \emph{Numeric}, developed by Jim Hugunin
    \item[2001] Several people used Numeric for writing sientific code.  Travis Oliphant, Eric Jones and Pearu Peterson merged their modules in one scientific super package: \emph{SciPy} was born.
    \item[2001-2004] \emph{numarray} was created by Perry Greenfield, Todd Miller and Rick White at the Space Science Telescope Institute as a replacement for Numeric.
    \item[2005] Travis Oliphant took \emph{Numeric} and assambled a multi dimensional array project \emph{SciPy core}. \emph{Numerix} was born but as there was a DSPs company with the same name, \emph{NumPy} was reborn. 
    \item[2006] Guido and Travis discussed which parts of \emph{NumPy} should go into Python standard libraries.  
  \end{description}
\end{frame}
%\section{Importing Data} % (fold)
%\label{sec:Importing Data}

% section Importing Data (end)
\subsection{Input/Output}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{http://scipy.org}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{figs/scipy}
\end{figure}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{scipi.io}
Maybe the most common IO in SciPy is to import and export Matlab files using \emph{loadmat/savemat}. In SciPy is easy to write/read them. 
%-------------------------------CODE
{\small
<<label='scipy',term=True>>=
import numpy as np
from scipy import io as spio
py_a = np.ones((2,2))
spio.savemat('ex.mat',{'mat_a': py_a})
py_mat = spio.loadmat('ex.mat')
py_mat['mat_a']
@
%-------------------------------END CODE
}
%where \verb|struct_as_record| loads the MATLAB structs as python objects rather than numpy structured arrays 
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{scipy.io}
  \emph{scipy.io} contains modules, classes and functions to read and write data to a variety of formats: 
\begin{description}
    \item[Matlab] \verb|loadmat(file_name[, mdict, appendmat])|
    \item[] \verb|savemat(file_name[, mdict, appendmat])|
    \item[Matrix Market] \href{http://math.nist.gov/MatrixMarket/}{http://math.nist.gov/MatrixMarket/}
    \item[] \verb|mminfo()|, \verb|mmread()| and \verb|mmwrite()|
    \item[Wav] Through \verb|scipy.io.wavfile|.
    \item[] \verb|read()|, \verb|write(file, rate, data)|
    \item[WEKA] ARFF is a text file format which support numerical, string and data values, with support of missing and sparse data.
    \item[] \verb|loadarff()| from \verb|arff| module
    \item[Netcdf] Through \verb|scipy.io.netcdf|
    \item[]  \verb|netcdf_file(filename[, mode, mmap, version])|

\end{description}

\end{frame}

\section{Statistics}
\subsection{First statistics} % (fold)
\label{ssub:First statistics}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Statistics}
\begin{figure}[!htb]
    \includegraphics[width=\textwidth]{figs/nine}
\end{figure}
\end{frame}



% subsubsection First statistics (end)%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Statistics}
    \begin{block}{scipy.stats}
    Contains statistical tools and probabilistic description of random processes.
    \end{block}  
   \pause \begin{block}{numpy.random}
    Contains random number generators for various random process. 
    \end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Main Stats functions}
    \begin{itemize}
        \item scipy.mean()
        \item scipy.var()
        \item scipy.std()
        \item scipy.median()
        \item scipy.scoreatpercentile()
        \item stats.describe() 
        \item stats.mode()
        \item stats.moment()
   \end{itemize}
\end{frame}
\subsection{Probability Distributions} % (fold)
\label{ssub:Probability Distributions}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Probability Distributions}
  \begin{block}{}
  \begin{itemize}
      \item  Scipy has functions that deal with several common probability distributions. 
        \item Currently there are 81 continuous probability distributions and 10 discrete distributions. 
        \item These are defined in the scipy.stats sub-package. 
        \item This package also defines several statistical functions.
    \end{itemize} 
  \end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{ Prob Distributions}
\begin{block}{Continuous PDFs}
 \begin{description}
      \item[norm] Normal or Gaussian
    \item[chi2] Chi-squared
    \item[t] Student's T
    \item[uniform] Uniform
  \end{description}
\end{block} 

\begin{block}{Discrete PDFs}
\begin{description}
    \item[binom] Binomial
    \item[poisson] Poisson 
\end{description}
\end{block}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Working with PDFs I }
  There are two ways of using probability distribution functions:
\begin{itemize}
    \item Generate a frozen distribution object and then work with the methods of this object.
%-------------------------------CODE
<<term=TRUE, label='pdf 1'>>=
from scipy import stats
N = stats.norm(loc=1, scale=0.5)
@
%-------------------------------END CODE
    We can then draw random numbers that follow the distribution we just defined:
%-------------------------------CODE
<<term=TRUE>>=
N.rvs(10)
@
%-------------------------------END CODE

\end{itemize}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Working with PDFs II}
Alternatively: 
\begin{itemize}
    \item Use functions in the appropriate class by always passing the parameters that define the distribution, when calling functions associated with the distribution.


    \item For example, to draw a random number from a Gaussian or Normal distribution with mean = 2 and standard deviation = 0.2 we can write:
%-------------------------------CODE
<<term=TRUE>>=
from scipy import stats
stats.norm.rvs(loc=2, scale=0.2, size=3)
@
%-------------------------------END CODE
\end{itemize}


\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{stats.describe()}
  %-------------------------------CODE
{ \small
<<term=True, label='describe'>>=
from scipy import stats
R = stats.norm.rvs(loc = 1, scale=0.5, size=1000)
n, min_max, mean, var, skew, kurt = stats.describe(R)
print("Number of elements: {0:d}".format(n))
print("Minimum: {0:8.6f} Maximum: {1:8.6f}".format(min_max[0], min_max[1]))
print("Mean: {0:8.6f}".format(mean))
print("Variance: {0:8.6f}".format(var))
print("Skew : {0:8.6f}".format(skew))
print("Kurtosis: {0:8.6f}".format(kurt))
@
}
  %-------------------------------END CODE
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Working with PDFs III}
Similarly, the value of the PDF at any value of the variate can be obtained using the function \verb|pdf| of the concerned distribution,
%-------------------------------CODE
<<term=TRUE>>=
stats.norm(1,loc=2,scale=0.2)
@
%-------------------------------END CODE
We can also pass an array of values to this function, to get the PDF at the specified values of the variate:
%-------------------------------CODE
<<term=TRUE>>=
N = stats.norm(loc=2, scale=0.2)
N.pdf([-1,2])
@
%-------------------------------END CODE   
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Multivariate random processes}
\begin{block}{Multivariate Random Processes}
Are provided by the \verb|np.random.multivariate| family.
\end{block}
\begin{block}{}
Could you create and plot a multivariate normal with:
\begin{align}
       \vec \mu & = (0, 0) \\
        \Sigma & = \left( \begin{array}{ccc}
            1 & 0.5 \\
            0.5 & 1
        \end{array} \right)
\end{align}
\end{block}

\end{frame}
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Solution}
\begin{columns}[c]
\column{0.5\textwidth}
%-------------------------------CODE
\small 
<<term=False,echo=True,fig=FALSE>>=
mean = [0,0]
cov = [[1,0.5],[0.5,1]]
import matplotlib.pyplot as plt
x,y = \
    np.random.multivariate_normal(\
        mean,cov,500).T
plt.plot(x,y,'bo') 
plt.axis('equal')
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}


%----------------------------FRAME------------------------------------
%\begin{frame}[fragile]\frametitle{Probability Mass Functions}
%For discrete variates the probability mass function (PMF) gives the probability of the variate having a value x.
%For example, for a binomial distribution with $p = 0.7$ and number of trials $n = 5$ we can calculate the PMF using the following:  
%-------------------------------CODE
%<<term=TRUE>>=
%tries = range(10)
%print(stats.binom.pmf(tries,5,0.7))
%@
%%-------------------------------END CODE
%\end{frame}
\subsection{Density Estimation} % (fold)
\label{sub:Density Estimation}

% subsection Density Estimation (end)
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Density Estimation}
  Let's generate a random process and estimate its probability density function (PDF):
%-------------------------------CODE
<<term=True>>=
x = np.random.normal(size=2000)
cuts = np.arange(-6,6)
cuts
hist = np.histogram(x, bins=cuts, normed=True)[0]
bins = (cuts[1:] + cuts[:-1])/2. 
bins 
@
%-------------------------------END CODE
\end{frame}

%%
%import matplotlib
%matplotlib.rcParams.update({'figure.figsize' : (4,2),
%                       'savefig.dpi': 200,
%                        'font.size' : 10 })
%
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Density Estimation}


\begin{columns}[c]
\column{0.5\textwidth}
%-------------------------------CODE
<<term = False>>=
from scipy import stats
import matplotlib.pyplot as pl
x_pdf = stats.norm.pdf(bins)
pl.plot(bins,hist)
pl.plot(bins,x_pdf)
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<fig=True,echo=False>>=
pl.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}\frametitle{Exercise}
  \begin{block}{Exercise}
  Generate a realization of 1000 samples following a Poisson distribution with a parameter of your choice.
 \begin{itemize}
     \item Search for the Poisson methods documentation. Can you estimate the parameter of your own distribution?
 \end{itemize}
  \end{block}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Solution}
\begin{block}{Poisson Probability Mass Distribution}
\begin{align}
    f_{Poiss}( \lambda ) &= \frac{\lambda^k e^{- \lambda}}{k!}\\
\lambda & = E(X)
\end{align}
\end{block}
%-------------------------------CODE
<<term=TRUE>>=
from pylab import plot,show,hist,figure,title
from scipy.stats import poisson
mu = 2.4
R = poisson.rvs(mu, loc=0, size=1000)
print("Mean: {0:1.2f}".format( R.mean() ) ) 
@
Note that there also SciPy variants, \verb|scipy.mean()|, \verb|scipy.std()|.
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Fitting}
    Distribution fitting is the procedure of selecting a statistical distribution that best fits to a dataset generated by some random process. In this post we will see how to fit a distribution using the techniques implemented in the Scipy library. 

%-------------------------------CODE
\small
<<term=TRUE>>=
from scipy.stats import norm
from numpy import linspace
from pylab import plot,show,hist,figure,title

data = norm.rvs(loc=0, scale=1, size=150) 
param = norm.fit(data)
param
x = linspace(-5,5,100)
pdf_fitted = norm.pdf(x, loc=param[0], scale=param[1])
pdf = norm.pdf(x)
@
%-------------------------------END CODE
%----------------------------FRAME------------------------------------
 
\end{frame}
\begin{frame}[fragile]\frametitle{Fitting}

\begin{columns}[c]
 \column{0.5\textwidth}
 % -------------------------------CODE
<<label='fitting',fig=False,term=False>>=
title('Normal distribution')
plot(x,
    pdf_fitted,'r-',
    x,pdf,'b-')
hist(data,normed=1,alpha=.3)
@
%
\column{0.5\textwidth}
%-------------------------------CODE
<<fig=True,echo=False>>=
show()
@
%-------------------------------END CODE   
\end{columns}    
\end{frame}

% subsubsection Probability Distributions (end)

\subsection{Statistical Testing} % (fold)
\label{sub:Statistical Testing}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Statistics made easy}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.7\textwidth]{figs/statisticsmadeeasy}
\end{figure}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Contingency tables}
%-------------------------------CODE
<<label='contingency',term=TRUE>>=
from scipy.stats.contingency import expected_freq 
obs = np.array([[10,20,10],[20,20,10]])
obs
@
%-------------------------------END CODE  
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{$\chi^2$-test}
This function computes the chi-square statistic and p-value for the hypothesis test of independence of the observed frequencies in the contingency table observed. 
%-------------------------------CODE
<<label='chi2',term=TRUE>>=
from scipy import stats
stats.chi2_contingency(obs)
@
%-------------------------------END CODE  

\end{frame}
% subsection Statistical Testing (end)

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Fisher exact test}
 \begin{block}{Example}
 Say we spend a few days counting whales and sharks in the Atlantic and Indian oceans. In the Atlantic ocean we find 8 whales and 0 shark, in the Indian ocean 2 whales and 5 sharks. Then our contingency table is:
\begin{center}
    
\begin{tabular}{ l c r }
   & Atlantic & Indian \\
  whales & 8 & 2 \\
  sharks & 0 & 5 \\
\end{tabular}
\end{center}
%-------------------------------CODE
 \end{block}
<<label='fisher',term=TRUE>>=
oddsratio, pvalue = stats.fisher_exact([[8, 2], [1, 5]])
pvalue
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{t-test}
  \begin{block}{ttest\_ind()}
Calculates the T-test for the means of TWO INDEPENDENT samples of scores. 
  \end{block}
%-------------------------------CODE
<<label='ttest',term=TRUE>>=
rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
rvs2 = stats.norm.rvs(loc=5,scale=10,size=500)
stats.ttest_ind(rvs1,rvs2)
rvs3 = stats.norm.rvs(loc=7,scale=10,size=500)
stats.ttest_ind(rvs1,rvs3)
@
%-------------------------------END CODE
\end{frame}



%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{t-test (matched)}
  \begin{block}{ttest\_ind()}
Calculates the T-test for the means of TWO MATCHED samples. 
  \end{block}
{ \small
%-------------------------------CODE
<<label='ttest',term=TRUE>>=
rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
rvs2 = (stats.norm.rvs(loc=5,scale=10,size=500) +
    stats.norm.rvs(scale=0.2,size=500))
stats.ttest_rel(rvs1,rvs2)
rvs3 = (stats.norm.rvs(loc=8,scale=10,size=500) +
     stats.norm.rvs(scale=0.2,size=500))
stats.ttest_rel(rvs1,rvs3)
@
}
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{More tests}
  \begin{description}
      \item[mannwhitneyu()] Computes the Mann-Whitney rank test on samples x and y.
    \item[spearmanr] Calculates a Spearman rank-order correlation coefficient and the p-value.
    \item[pearsonr] Calculates a Pearson correlation coefficient and the p-value for testing.
    \item[f\_oneway] Performs a 1-way ANOVA.
    \item[oneway] Test for equal means in two or more samples from the normal distribution.
    \item[normaltest] Tests whether a sample differs from a normal distribution.
    \item[kruskal] Compute the Kruskal-Wallis H-test for independent samples.
  \end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Plot tests}
  \begin{description}
      \item[probplot] Calculate quantiles for a probability plot against a theoretical distribution. 
  \end{description}
 \begin{columns}[c]
    \column{0.4\textwidth}
\tiny
<<term=False,echo=TRUE,fig=False>>=
import scipy.stats as stats
import matplotlib.pyplot as plt 
nsample = 100
np.random.seed(7654321)
ax1 = plt.subplot(221)
x = stats.t.rvs(3, size=nsample)
res = stats.probplot(x, plot=plt)
ax2 = plt.subplot(222)
x = stats.t.rvs(25, size=nsample)
res = stats.probplot(x, plot=plt)
ax3 = plt.subplot(223)
x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],
     size=(nsample/2.,2)).ravel()
res = stats.probplot(x, plot=plt)
ax4 = plt.subplot(224)
x = stats.norm.rvs(loc=0, scale=1, size=nsample)
res = stats.probplot(x, plot=plt)
@
\column{0.6\textwidth}
%-------------------------------CODE
<<term=TRUE,echo=False,fig=True>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

\section{Some Calculus} % (fold)
\label{sec:Some Calculus}
\subsection{Linear Algebra}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{scipy.linalg}
  \begin{block}{}
    The \verb|scipy.linalg| module provides standard linear algebra operations, relying on an underlying efficient implementation (BLAS, LAPACK). Some of the main functions are:
  \end{block}
\begin{description}
    \item[inv] Compute the inverse of a matrix.
    \item[pinv] Compute the (Moore-Penrose) pseudo-inverse of a matrix.
%    \item[lstsq] Least-Squares Solution to $A \cdot x = b$.
    \item[solve] Solve the equation $A\cdot X  = B$  for $X$. 
    \item[det]  Compute the determinant of a matrix.
    \item[norm] Matrix or vector norm.
\end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{scipy.linalg}
  \begin{description}
      \item[eig] Solve an ordinary or generalized eigenvalue problem of a square matrix (\verb|eigh()| for complex).
    \item[svd] Singular Value Decomposition.
    \item[orth] Construct an orthonormal basis for the range of A using SVD.
    \item[qr] Compute QR decomposition of a matrix.
    \item[expm] Compute the matrix exponential using Pade approximation. 
    \item[logm] Compute matrix logarithm.
    \item[sinm] Matrix sin/cos/tan. 
    \item[cosm] e.g. $cos(A) = I - \frac{1}{2!}A^2 + \frac{1}{4!}A^4 - \cdots $
    \item[tan]
    \item[funm] Evaluate a matrix function specified by a callable.
  \end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{solve()}
  \begin{block}{$A \cdot x = b$}
  Given $a$ and $b$, solve for x.
  \end{block}
%-------------------------------CODE
<<label='solve',term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy import linalg
from numpy import dot
a = np.array([[3,2,0],[1,-1,0],[0,5,1]])
b = np.array([2,4,-1])
x = linalg.solve(a,b)
x
np.dot(a, x) 
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{pinv()}
  \begin{block}{pinv()}
  Calculate a generalized inverse of a matrix using a least-squares solver.
  \end{block}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
a = np.random.randn(5, 3)
B = linalg.pinv(a)
np.allclose(a, dot(a, dot(B, a)))
np.allclose(B, dot(B, dot(a, B)))
@
%-------------------------------END CODE

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{numpy's allclose() }
  \begin{block}{numpy.allclose()}
  %\pause \begin{block}{np.allclose()}
Returns True if two arrays are element-wise equal within a tolerance.
   \begin{equation}
    abs(a-b) \leq atol + rtol \cdot abs(b)
\end{equation}
\end{block}

\begin{description}
     \item  Relative difference: $rtol \cdot abs(b)$. 
     \item[rtol] Defaults to $1e^{-5}$.
    \item[atol] Defaults to $1e^{-8}$. 
\end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Singular Value Decomposition}
\begin{block}{Matrix Decompositions}
SVD is commonly used in statistics and signal processing. Many other standard decompositions (QR, LU, Cholesky, Schur), as well as solvers for linear systems, are available in scipy.linalg.
\end{block}
%-------------------------------CODE
<<label='svd1',term=TRUE,echo=TRUE,fig=FALSE>>=
Mat = np.arange(9).reshape((3, 3)) + np.diag([1, 0, 1])
uMat, S, vMat = linalg.svd(Mat)
S
@
%-------------------------------END CODE
%-------------------------------CODE
\pause 
<<label='svd2',term=TRUE,echo=TRUE,fig=FALSE>>=
sMat = np.diag(S)
recMat =  uMat.dot(sMat).dot(vMat)
np.allclose(recMat,Mat)
@
%-------------------------------END CODE
  
\end{frame}
% section Some Calculus (end)
\subsection{Fast Fourier Transforms}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Fast Fourier Transforms}
  \begin{block}{}
  Ok, up to this, boring algebra, I need some action!!
  \end{block}
\pause \begin{block}{FFT through scipy.fftpack}
The scipy.fftpack module allows to compute fast Fourier transforms.
In this example we will:
\begin{itemize}
    \item Generate a noisy signal.
    \item Detect a high frequency component (noise).
    \item Filter this noise in Fourier. 
    \item Plot the filtered signal. 
\end{itemize}
\end{block}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Signal Generation}
  \begin{block}{}
  A typical noisy input may look like the following:
 \end{block}

<<label='fft',term=TRUE,echo=TRUE,fig=FALSE>>=
time_step = 0.02
period = 5.0
time_vector = np.arange(0, 20, time_step)
signal = np.sin(2.0 * np.pi * time_vector / period) + \
 0.4 * np.random.randn(time_vector.size)
@
\end{frame}



\begin{frame}[fragile]\frametitle{Signal Generation}

\begin{columns}[c]
  \column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=FALSE>>=
plt.plot(time_vector, signal)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
@
%-------------------------------END CODE
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<label='fft2',term=False,echo=False,fig=True>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{FFT}
For convenience, we need to first define a vector with the discrete Fourier Transform sample frequencies: 

%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy import fftpack
freqs = fftpack.fftfreq(signal.size, d=time_step)
freqs[0:5]
freqs[-5:-1] 
@
%-------------------------------END CODE
And the transformation itself: 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
sig_fft = fftpack.fft(signal)
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{FFT}
We can find the peak on the signal as follows. First select positive frequencies.   

%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
ind = np.where(freqs > 0 )
freqs_p = freqs[ind]
signal_abs = np.abs(sig_fft)[ind]
@
Then, where do we find the maximum amplitude ?
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
fpeak = freqs_p[signal_abs.argmax()]
print fpeak, 1./period 
@
%-------------------------------END CODE

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{FFT}
  
Let's filter the noise above the signal and compute the inverse transform: 

\begin{columns}[c]
    \column{0.5\textwidth}
%-------------------------------CODE
\small 
<<term=False,echo=True,fig=FALSE>>=
sig_fft[np.abs(freqs) > fpeak] = 0
main_signal = fftpack.ifft(sig_fft)
plt.figure()
plt.plot(time_vector, signal)
plt.plot(time_vector, 
    main_signal, linewidth=5)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
@
%-------------------------------END CODE        
    \column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=True>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge!}
Let's consider this noisy image.\tiny{\href{https://www.dropbox.com/s/a73c0lla7qdjqiy/orionnebulaN.jpg}{https://www.dropbox.com/s/a73c0lla7qdjqiy/orionnebulaN.jpg Download link}}

 \begin{columns}[c]

    \column{0.5\textwidth}    
    \begin{figure}[!htb]
      \centering
     \includegraphics[width=0.6\textwidth]{challenges/orionnebulaN}
     \caption{Picture with periodic noise.}
     \label{fig:}
    \end{figure}
   \column{0.5\textwidth}  
    \begin{block}{}
    Use the 2D FFT implementation in \emph{scipy.fftpack} to remove the noise int the picture:
        \begin{enumerate}
            \item Import the image into ipython through \verb|plt.imread()|
            \item Compute the power spectrum of the Fourier Transform and plot it. 
            \item Cut the high-frequency part zeroing the 2D Fourier Transform matrix. 
             \item Apply the inverse Fourier transform to retrieve the original image.
        \end{enumerate}
    \end{block}
 \end{columns}

\end{frame}




\subsection{Optimization}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Optimization}
  \begin{block}{Optimization}
  Optimization is the problem of finding a numerical solution to a minimization or equality.
  \end{block}

\pause \begin{block}{scipy.optimize}
The scipy.optimize module provides useful algorithms for:
\begin{enumerate}
    \item Function minimization (scalar or multi-dimensional)
    \item Curve fitting.
    \item Root finding.
\end{enumerate} 
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Finding a Minimum for a Scalar function}
  Let's define the following function:
\begin{equation}
    f(x)=x^2 + 10 sin(x)
\end{equation}
\begin{columns}[c]
    \column{0.5\textwidth}
%-------------------------------CODEA
\small
<<term=False,echo=True,fig=False>>=
def f(x):
    return x**2 + 10*np.sin(x)

x = np.arange(-10, 10, 0.1)
plt.plot(x, f(x))  
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Finding a Minimum for a Scalar Function}
 The general and efficient way to find a minimum for this function is to conduct a gradient descent starting from a given initial point. The BFGS algorithm is a good way of doing this:
 %-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy import optimize 

optimize.fmin_bfgs(f, 0)
@
 %-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Brute Force Optimization}

But, watch out! 
%-------------------------------CODE
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
optimize.fmin_tnc(f, 5, disp=0)
array([4.60643939])
\end{minted}

%-------------------------------END CODE
\pause
In case there is no information on the neighborhood - and therefore we have no clues on where to set up the initialization -  we might need to search for a global minimum through brute force.
 %-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
grid = (-10, 10, 0.1)
xmin_global = optimize.brute(f, (grid,))
xmin_global
@
 %-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Optimization}
  
In practical use \verb|scipy.optimize.brute()| is not usable. There are more advanced alternatives in other functions and packages. 
\begin{description}
    \item[fminboun(f,a,b)] contrained to the $(a,b)$ interval.  
    \item[anneal()] \verb|scipy.optimize.anneal()| offers an alternative using simulated annealing.
     \item[fmin\_cg()] Conjugate gradient methods.   
   \item[fmin\_ncg()] Newton Methods (Nelder-Mead).
   \item[fmin] Gradient-less methods 
    \item[Packages] \href{http://openopt.org/Welcome}{OpenOpt} 
    \item[] \href{https://github.com/xuy/pyipopti}{IPOPT}
    \item[] \href{http://pagmo.sourceforge.net/pygmo/index.html}{PyGMO}
    \item[] \href{http://pyevolve.sourceforge.net/}{PyEvolve}

\end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Optimization}
  \begin{figure}[!htb]
      \centering
      \includegraphics[width=\textwidth]{figs/optims}
      \label{fig:}
  \end{figure}
\tiny{\href{http://scipy-lectures-scipy-lectures.github.com/advanced/mathematical_optimization/index.html#gradient-based-methods}{Source}}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Finding roots}
  Defined as the $x|_{f(x)=0}$. Roots are found with help of \verb|fsolve|. For the case of $f(x)=x^2 + 10 sin(x) $:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
optimize.fsolve(f, 1)
@
As seen from the plot of the function in the previous slides, there may exist more than one root. The root we find depends solely on the intial guess.

%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
optimize.fsolve(f, -2.5)
@
%-------------------------------END CODE
    
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Curve Fitting}
  Assume we observe our process that follows the function $f(x)$, but we have some noise to our measurements. 

\begin{columns}[c]
    \column{0.5\textwidth}
%-------------------------------CODE
\small
<<term=False,echo=TRUE,fig=False>>=
x = np.linspace(-10, 10, num=20)
obs = f(x) + \
    10* np.random.randn(x.size)
@
%-------------------------------END CODE
   \column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
plot(x,obs,'go')
@
%-------------------------------END CODE
\end{columns}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Curve Fitting}

Aha! We suspect that our process follows : 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
def fguess(x, a, b):
    return a*x**2 + b*np.sin(x)
@
%-------------------------------END CODE

So we can try to fit $a$ and $b$ parameters. 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
init_pars=[2,2]
params, params_covariance = optimize.curve_fit(fguess, 
    x, obs, init_pars)
params

@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Curve Fitting}
 \begin{columns}[c]
     \column{0.5\textwidth}
%-------------------------------CODE
\small
<<term=False,echo=TRUE,fig=False>>=
plt.plot(x, f(x), 'b-', 
    label="f(x)")
plt.plot(x, fguess(x, *params),
     'r--', label="Fit")
plt.plot(x,obs,'go',
    label='Observations')
plt.legend()
plt.xlabel('x')
plt.ylabel('f(x)')
@
%-------------------------------END CODE    
     \column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
plt.show()
@
%-------------------------------END CODE
 \end{columns}
\end{frame}

\subsection{Interpolation}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Curve Fiting}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.7\textwidth]{figs/extrapolation}
\end{figure}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Interpolation}
The \verb|scipy.interpolate| is useful for fitting a function from experimental data and thus evaluating points where no measure exists.
Let's observe a process with oscillatory origin.
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
t = np.linspace(0, 1, 10)
N = (np.random.random(10)*2 - 1) * 1e-1
obs = np.sin(2 * np.pi * t) + N
@
We can use the interpolate classes for building a linear ``\emph{interpolator}''.


%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy.interpolate import interp1d
interpolator = interp1d(t, obs)
@
%-------------------------------END CODE  
Then we can use this object to evaluate our new data. 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
int_t = np.linspace(0, 1, 50)
int_obs = interpolator(int_t)
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
  \begin{block}{Challenge}
  Try to interpolate the same function with a cubic interpolation. Plot the original function, the result of the linear and cubic interpolation and the original observations.  
  \end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Interpolation}
\begin{columns}[c]
\column{0.7\textwidth}   
%-------------------------------CODE
<<term=False,echo=False,fig=True,width='0.5\textwidth'>>=
"""Generate the interpolation.png image for the interpolate
section of the Scipy tutorial
"""

import numpy as np
from scipy.interpolate import interp1d
import pylab as pl

measured_time = np.linspace(0, 1, 10)
noise = (np.random.random(10)*2 - 1) * 1e-1
measures = np.sin(2 * np.pi * measured_time) + noise

linear_interp = interp1d(measured_time, measures)
computed_time = np.linspace(0, 1, 50)
linear_results = linear_interp(computed_time)
cubic_interp = interp1d(measured_time, measures, kind='cubic')
cubic_results = cubic_interp(computed_time)

pl.plot(measured_time, measures, 'o', ms=6, label='measures')
pl.plot(computed_time, linear_results, label='linear interp')
pl.plot(computed_time, cubic_results, label='cubic interp')
pl.legend()

@
%-------------------------------END CODE

\end{columns}
\end{frame}

\subsection{Numerical Integration}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Integration}
There exists a generic integration routune: \verb|scipy.integrate.quad()|.   
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy.integrate import quad
res, err = quad(np.sin, 0, np.pi/2)
res,err
@
%-------------------------------END CODE
\begin{description}
    \item[odeint()]  General-purpose integrator using LSODA (Livermore Solver for Ordinary Differential equations (from \href{http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html}{ODEPACK} Library).  
\end{description}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Integrator example}
  \begin{figure}[!htb]
      \centering
      \includegraphics[width=0.3\textwidth]{figs/damper}
  \end{figure}
A damped spring-mass oscillator (2nd order oscillator). The dampig effect is linearly related to the velocity of the oscillations.
\begin{equation}
     {d^2x \over dt^2} + 2 \zeta \omega_0 {dx \over dt} + \omega_0^2 x =0
\end{equation}
where $ \omega_0^2 = k/m $, $k$ the spring constant, $m$ the mass and $\zeta =\frac{c}{2 m \omega_0}$ with $c$ as damping coefficient.


\end{frame}
\begin{frame}[fragile]\frametitle{Integrator example}

The damping ratio $\zeta=\frac{c}{2 m \omega_0}=\frac{c}{2m\sqrt{k\over m}}$ determines: 
\begin{description}

    \item[Overdamped ($\zeta > 1$)] The system returns to equilibrium without oscillating (exponencially decaying). Larger values of the damping ratio $\zeta$ return to equilibrium more slowly.
    \item[Critical damp  ($\zeta = 1$)] The system returns to equilibrium as quickly as possible without oscillating.
    \item[Underdamped ($0 < \zeta < 1$)] The system oscillates (at reduced frequency compared to the undamped case) with the amplitude gradually decreasing to zero.
    \item[Undamped ($\zeta = 0)$] The system oscillates at $\omega_0$.

\end{description}
The values
<<term=TRUE,echo=TRUE,fig=FALSE>>=
m, k, c = 0.5, 4, 0.4  # In kg, N/m, Ns/M
c / (2 * m * np.sqrt(k/m))
@
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Integrator example}
%----------------------------FRAME------------------------------------
We will use scipy's \verb|integrate.odeint()|. We need to transform the second order system into two first order equations for $Y=(y, \dot y)$. Let's define $\nu = 2 \zeta \omega_0 = {c \over m}$ and $ o = \omega_0^2={k \over m}$:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
nu, o  = c / m , k / m
@
%-------------------------------END CODE
Then, we can express $Y= (y, \dot y )$: 
\begin{align}
    y&=\dot x \\
    \dot y &= -\nu \dot x - o x
\end{align}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy.integrate import odeint
def dy(y, t, nu, o):
    return (y[1], -nu * y[1] - o  * y [0])
time_vec = np.linspace(0, 10, 100)
yarr = odeint(dy, (1, 0), time_vec, args=(nu, o))
@
%-------------------------------END CODE
\end{frame}


%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Integrator Example}
\begin{columns}[c]
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=True,fig=False>>=
pl.plot(time_vec, 
    yarr[:, 0], label='y')
pl.plot(time_vec, 
    yarr[:, 1], label="y'")
pl.legend()
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}




\subsection{Signal and Image Processing}
%----------------------------FRAME 2 cols + header (box)-------------
\begin{frame}[plain]\frametitle{Signal Processing}
\begin{block}{scipy.signal}
\small This module includes a large number of functions for signal processing. Covering the following areas: 
\end{block}

\small \begin{columns}[c]
    \column{0.5\textwidth}

    \begin{block}{Convolution}
         \begin{itemize}
             \item convolve()
                \item fftconvolve()
           \item correlate()
        \end{itemize}
    \end{block}
    \begin{block}{Waveforms}
         \begin{itemize}
        \item chirp()
         \item square()
            \item sawtooth()
       \end{itemize}
    \end{block}


\column{0.5\textwidth}

\begin{block}{Wavelets}
  \begin{itemize}
   \item daub()
    \item cwt()
 \end{itemize}
\end{block}
    \begin{block}{b-Splines}
         \begin{itemize}
             \item bspline()
             \item spline\_filter()
        \end{itemize}
    \end{block}

\begin{block}{Peak Finding}
 \begin{itemize}
   \item find\_peaks\_cwt()
 \end{itemize}
\end{block}
\end{columns}
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Signal Processing at scipy.signal}
\begin{columns}[c]
\column{0.5\textwidth}
\begin{block}{Filter Design}
\begin{itemize}
    \item firwin()
    \item freqz()
    \item freqs()
    \item iirdesign()
    \item iirfilter()
    \item kaiserord()
    \item remez()
   \item butter()
    \item buttord()
    \item cheb1()
    \item cheb1ord() 
\end{itemize}
\end{block}

\column{0.5\textwidth}
\begin{block}{Filtering}
\begin{itemize}
    \item order\_filter()
    \item medfilt()
    \item wiener()
    \item decimate()
    \item resample()
    \item detrend()
    \item get\_window()
    \item lfilter()
\end{itemize}
\end{block}

\end{columns}
\end{frame}

%----------------------------FRAME 2 cols + header (box)-------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{15 minutes}
Use scipy.signal for: 
 \begin{enumerate}
     \item Create a linear signal.
    \item Add a random noise process.
    \item \emph{detrend} the signal. 
 \end{enumerate}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{ Low Pass Filters}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.75\textwidth]{figs/filters}
\end{figure}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Low Pass Filters}
\begin{block}{Parameters}
\begin{description}
    \item[$\omega_p$] Passband.  This is the frequency range which we desire to let the signal through with minimal attenuation. In the scipy functions this is in normalized frequency, $1> \omega_p  > 0$, where 1 is the Nyquist frequency.
    \item[$\omega_s$] Stopband.  This is the frequency range which the signal should be attenuated  $1> \omega_s  > 0$.
    \item[$R_p, gpass$] The max variation in the passband, in decibels.
    \item[$A_s, gstop$] The min attenuation in the stopband, in decibels.
\end{description}
\end{block}
\Tiny Notes:
{\tiny The cutoff frequency is the -3dB point.  If the cutoff frequency is required the algorithm will work to meet the -3dB point at the $\omega_c$ frequency.\\
$\omega_p$ is the pass frequency, this is the last point were -gpass ($R_p$)
}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{IIR filter design}

A number of filters are available through the \verb|iirdesign()| function:

\tiny \begin{tabular}{|l|p{1.5cm}|p{1.5cm}|l|p{1.5cm}|p{2cm}|}\hline
    Filter	& Transition &  Passband &Stopband&Phase&Comments \\ \hline
Bessel & 	Knee? What knee? & 	Monotonic&  	Monotonic & 	Near-linear & 	s-to-z mappings distort phase. FIR usually more efficient for linear phase \\

Butterworth & 	Rounded & 	Maximally flat, monotonic&  	Monotonic & 	nonlinear near cutoff & 	Easy to design by had Maple syrup is better on waffles \\

Chebychev I & 	Sharp & 	Ripples & 	Monotonic & 	Worse & 	Easy to design by hand \\

Chebychev II & 	Sharp&  	Monotonic 	& Ripples & 	Worse & 	Somewhat more complicated design than Chebychev I \\

Elliptic & 	Maximally sharp & 	Ripples & 	Ripples & 	Drunk fly on cross- country skies in a tornado & 	Not viable for design by hand \\ \hline

\end{tabular}
\tiny Verbatim from \emph{Grover and Deller, Digital Signal Processing and the Microcontroller}

\small
%-------------------------------CODE
\begin{minted}[bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
iirdesign(Wp, Ws, Rpl, Asl, ftype='butter')
\end{minted}
%-------------------------------END CODE
\end{frame}



%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example FIR design}
Let's define two convenience plots. 
\small
%-------------------------------CODE
<<label='mfreqz',term=False,echo=TRUE,fig=FALSE>>=
def mfreqz(b,a=1):
   w,h=signal.freqz(b,a)
   h_dB=20*log10(abs(h))
   subplot(211)
   plot(w/max(w),h_dB)
   ylim(-150, 5)
   ylabel('Magnitude (db)') 
   xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
   title(r'Frequency response')
   subplot(212)
   h_Phase = unwrap(arctan2(imag(h),real(h)))
   plot(w/max(w),h_Phase)
   ylabel('Phase (radians)')
   xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
   title(r'Phase response')
   subplots_adjust(hspace=0.5)
@
%-------------------------------END CODE
\end{frame}





%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example FIR design}
%-------------------------------CODE
\small
<<term=False,echo=TRUE,fig=FALSE>>=
def impz(b,a=1):
   impulse = repeat(0.,50); impulse[0] =1.
   x = arange(0,50)
   response = signal.lfilter(b,a,impulse)
   subplot(211)
   stem(x, response)
   ylabel('Amplitude') 
   xlabel(r'n (samples)')
   title(r'Impulse response')
   subplot(212)
   step = cumsum(response)
   stem(x, step)
   ylabel('Amplitude') 
   xlabel(r'n (samples)')
   title(r'Step response')
   subplots_adjust(hspace=0.5)   
@
%-------------------------------END CODE

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example Low Pass FIR design}
\begin{block}{Low Pass Filter}
For designing lowpass FIR filters you can use the function \verb|signal.firwin|. Define the window length, cut off frequency and the window:
\end{block}

%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy import signal 
from numpy import log10
from pylab import *
n = 61
a = signal.firwin(n, cutoff = 0.3, window = "hamming")
mfreqz(a)
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example FIR design}


\begin{columns}
    
\column{0.8\textwidth}
a = signal.firwin(n, cutoff = 0.3, window = "hamming")
%-------------------------------CODE
<<label='mf1',term=False,echo=False,fig=True>>=
show()
@
%-------------------------------END CODE

\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example FIR design}

\begin{columns}
\column{0.85\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
impz(a)
pl.show()
@
%-------------------------------END CODE%-------------------------------END CODE
\end{columns}
\end{frame}



%\subsection{Image Processing}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{scipy.ndimage}
\begin{block}{scipy.ndimage}
This package contains various functions for multi-dimensional image processing, mainly organized in four function groups:
\begin{itemize}
    \item Filters (convolve, correlate, ...)
    \item Fourier Filters (Gaussian fourier filters, ...)
    \item Interpolation (affine\_transform, rotate, ... )
    \item Measurements (histogram, extrema, ...)
    \item Morphology (closings, openings, ...)
    \item Utility (imread)
\end{itemize}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Geometrical transformations on images}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy import ndimage
from scipy import misc
lena = misc.lena()
shifted_lena = ndimage.shift(lena, (50, 50))
shifted_lena2 = ndimage.shift(lena, (50, 50), mode='nearest')
rotated_lena = ndimage.rotate(lena, 30)
cropped_lena = lena[50:-50, 50:-50]
zoomed_lena = ndimage.zoom(lena, 2)
zoomed_lena.shape
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Geometrical transformations on images}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
subplot(131)
pl.imshow(lena, cmap=cm.gray)
axis('off')
subplot(132)
pl.imshow(shifted_lena, cmap=cm.gray)
axis('off')
subplot(133)
pl.imshow(rotated_lena, cmap=cm.gray)
axis('off')
subplots_adjust(hspace=0)   
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Image Filtering}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy import misc
import numpy as np
from scipy import signal
lena = misc.lena()
noisy_lena = np.copy(lena).astype(np.float)
noisy_lena += lena.std()*0.5*\
    np.random.standard_normal(lena.shape)
blurred_lena = ndimage.gaussian_filter(noisy_lena, sigma=3)
median_lena = ndimage.median_filter(blurred_lena, size=5)
wiener_lena = signal.wiener(blurred_lena, (5,5))
@
%-------------------------------END CODE

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Image Filtering}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
subplot(141)
pl.imshow(noisy_lena, cmap=cm.gray)
axis('off')
subplot(142)
pl.imshow(blurred_lena, cmap=cm.gray)
axis('off')
subplot(143)
pl.imshow(median_lena, cmap=cm.gray)
axis('off')
subplot(144)
pl.imshow(wiener_lena, cmap=cm.gray)
axis('off')
subplots_adjust(hspace=0)   
@
%-------------------------------END CODE
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Measurements}

Let us first generate a nice synthetic binary image.
%-------------------------------CODE
<<term=False,echo=TRUE,fig=False>>=
x, y = np.indices((100, 100))
sig = np.sin(2*np.pi*x/50.)*\
    np.sin(2*np.pi*y/50.)*(1+x*y/50.**2)**2
mask = sig > 1
@
%-------------------------------END CODE
\begin{columns}[c]
    \column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.imshow(sig)
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.imshow(mask)
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Measurements}
Play with the following code, plot sig, and the labels:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
labels, nb = ndimage.label(mask)
areas = ndimage.sum(mask, labels, xrange(1, labels.max()+1))
areas
maxima = ndimage.maximum(sig, labels, xrange(1, labels.max()+1))
maxima
ndimage.find_objects(labels==4)
sl = ndimage.find_objects(labels==4)
import pylab as pl
pl.imshow(sig[sl[0]]) 
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Measurements}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{frame}






%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
 \href{https://www.dropbox.com/s/cgc14z3rafshjho/MV_HFV_012.jpg}{https://www.dropbox.com/s/cgc14z3rafshjho/MV\_HFV\_012.jpg Download Image}.
\begin{columns}[c]
    \column{0.5\textwidth}
Download the following image \href{https://www.dropbox.com/s/cgc14z3rafshjho/MV_HFV_012.jpg}{Download Image}. \\ 
This file shows a Scanning Element Microscopy image of  glass sample (light gray matrix) with some bubbles (on black) and unmolten sand grains (dark gray).    \\
Our goal is to determine the fraction of the sample covered by these three phases, and to estimate the typical size of sand grains and bubbles, their sizes, etc.
 
   \column{0.5\textwidth}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{figs/MV_HFV_012}
\end{figure}
\end{columns}


\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{enumerate}
    \item Open the image.
    \item Crop unwanted segments.
    \item Filter the image with a median filter.
    \item Check the effect of the filter on the histogram.
    \item From the histogram. Set thresholds for:
    \begin{itemize}
        \item Sand pixels.
        \item Glass pixels.
        \item Bubble Pixels.
    \end{itemize}
    \item Display an image with the colored elements.
    \item Could you estimate the mean size of bubbles?
\end{enumerate}


\end{frame}


%\subsection{Special Functions}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Special Functions}
There is a rich library for computing Special Functions, brought by \verb|scipy.special|, main functions are:

\begin{description}
    \item[Elliptic Funs] \verb|sllipj()|, \verb|ellipj()|, ...
    \item[Bessel Funs] \verb|jn()|, \verb|jv()|,\verb|jve()|, ... 
    \item[Statistical Funs] \verb|btdtr()|, \verb||. It is better to use \verb|scipy.stats| functions.
    \item[Gamma Funs] \verb|gamma()|, \verb|multigamma()|, ...
    \item[Error Funs] \verb|erf()|, \verb|erfc|, ...  
    \item[Legendre Funs] \verb|lpmv|, \verb|legendre()|, ...
    \item[Hypergeom.] \verb|hypf1()|, ...
    \item[++] \url{http://docs.scipy.org/doc/scipy/reference/special.html}{And more...}
\end{description}
\end{frame}

\section{Storage Schemes and code profiling}
\subsection{Introduction to storage of large data}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{A \emph{dense matrix} is a matematical object for data storage of a 2D array ofvalues. }
\begin{itemize}
    \item Memory is allocated once for all items
    \item Storage in a contiguous chunk (aka NumPy ndarray)
    \item The access to individual items is fast.
\end{itemize}
\begin{block}{Why Space Matrices?}
It's this memory thing...  Imagine adjacency matrices for:
    \begin{itemize}
        \item All Graph theory.
        \item 40000 proteins in a typical PPI dataset.
        \item $10e^7$ Facebook users in a typical country.
        \item Partial Differential Equations (PDEs), Finite Elements and others. 
    \end{itemize}
\end{block}

\end{frame}
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{Grow, my son, grow...}
\begin{columns}[c]
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=FALSE>>=
import numpy as np
import matplotlib.pyplot as plt
e = np.linspace(0,1e6,10)
v = 8 * (e**2)/1e9
plt.plot(e,v,lw=5)
plt.xlabel('size n')
plt.ylabel('mem (Gb)')
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
plt.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

 %----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Sparse Matrix}
 \begin{columns}[c]
     \column{0.5\textwidth}
        \begin{itemize}
            \item Sparse Matrix is an almost empty matrix.
            \item If a zero means nothing, let's store nothing.
            \item It's a form of compression, huge memory savings.
            \item \emph{Enables} applications.
         \end{itemize}
    \column{0.5\textwidth}
      \begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{figs/graph_g}
      \end{figure}
  \end{columns}
\end{frame}
 
\subsection{Storage Schemes} % (fold)
\label{ssub:Storage Scheme}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Storage Schemes}
There are seven storage schemes offered by \verb|scipy.sparse|:
\begin{description}
    \item[csc\_matrix] Compressed Sparse Column format.
    \item[csr\_matrix] Compressed Sparse Row format.
    \item[bsr\_matrix] Block Sparse Row format. 
    \item[lil\_matrix] Lists of Lists format.
    \item[dok\_matrix] Dictionary of Keys format.
    \item[coo\_matrix] COOrdiante format ($X_{ijk}$).
    \item[dia\_matrix] DIAgonal Matrix format. 
\end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{spmatrix}
 
\begin{description}
    \item[object] All \verb|scipy.sparse| classes are subclasses of \verb|spmatrix|.
 \begin{itemize}
    \item Default implementation of arithmetic ops.
    \item matrix/NumPy: toarray(),todense()
 \end{itemize}
    \item[Attributes]
\begin{description}
    \item[mtx.A] toarray().
    \item[mtx.T] Transpose.
    \item[mtx.H] Hermitian transpose.
    \item[mtx.real] Real part of complex matrix.
    \item[mtx.imag] Imaginary part of complex matrix.
    \item[mtx.size] Non-zero size.
    \item[mtx.shape] The number of rows/columns.
\end{description}
    \item[storage] In form of NumPuy arrays.
\end{description}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{COO matrix challenge}
\begin{block}{Check the documentation of sparse.coo\_matrix. Create a sparse matrix M so that it looks like the following}
<%
from scipy import sparse
import numpy as np
row = np.array([0, 3, 1, 0])
col = np.array([0, 3, 1, 2])
data = np.array([4, 5, 7, 9])
M = sparse.coo_matrix((data, (row, col)), shape=(4, 4))
%>
%-------------------------------CODE
<<term=True,echo=TRUE,fig=FALSE>>=
M.todense()
@
%-------------------------------END CODE
Can you slice this type of matrix? 
\end{block}

\end{frame}


% subsubsection Storage Scheme (end)
\subsection{Linear System Solvers} % (fold)
\label{sub:Linear_System_Solvers}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Solvers}
\begin{block}{SuperLU 4.0}
\begin{itemize}
    \item Included in SciPy.
    \item Real and Complex domains.
    \item Single and double precision.
\end{itemize}
\end{block}
\begin{block}{umfpack}
UMFPACK is a set of routines for solving unsymmetric sparse linear systems
\begin{itemize}
    \item Real and Complex domains.
    \item Double precision.
    \item Fast.
    \item See \verb|scikits.umfpack| and \verb|scikits.suitesparse|. 
\end{itemize}
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
import numpy as np
from scipy import sparse
mtx = sparse.spdiags([[1, 2, 3, 4, 5], [6, 5, 8, 9, 10]], [0, 1], 5, 5)
mtx.todense()
rhs = np.array([1, 2, 3, 4, 5])
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Example}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from scipy.sparse.linalg import dsolve
mtx1 = mtx.astype(np.float32)
x = dsolve.spsolve(mtx1, rhs, use_umfpack=False)
x
mtx1*x 
@
%-------------------------------END CODE
\end{frame}


% subsection Linear System (end)
\subsection{Others} % (fold)
\label{sub:other}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Eigensolvers}
\begin{block}{eigen module}
\begin{description}
    \item[arpack] A colection of Fortran77 subroutines to solver large scale eigenvalue problems.
    \item[lobpcg]  Locally Optimal Block Preconditioned Conjugate Gradient Method. See also the PyAMG module.
    \item[PyAMG] PyAMG is a library of Algebraic Multigrid (AMG) solvers. Check \href{http://code.google.com/p/pyamg/}{http://code.google.com/p/pyamg/}
\end{description}\end{block}
\begin{block}{Pysparse}
Pysparse is a fast sparse matrix library for Python. It provides several sparse matrix storage formats and conversion methods. It also implements a number of iterative solvers, preconditioners, and interfaces to efficient factorization packages.
\end{block}


\end{frame}

% subsection  (end)
\subsection{Notes On code optimization and profiling} % (fold)
\label{sub:Optimization_Workflow}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Writing code}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.65\textwidth]{figs/wtf}
\end{figure}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Coding in Science}
\begin{itemize}

    \item Things should be clever, but not too clever.
    \item Algorithms are optimal, both in speed as well as in readability.
    \item Classes, variables and functions are well named and make sense without having to think too much.
    \item You come back to it after a weekend off, and you can jump straight in.
    \item Things that will be reused are reusable.
    \item Write automated test cases
    \item Unit tests are easy to write.
\end{itemize}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Coding in Science}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
def p(n):
    """print 3.1415   """
    return n**2
exec(p.__doc__) # hidd
@
%-------------------------------END CODE
\end{frame}


% subsection Optimization (end)


\subsection{Profiling your code} % (fold)
\label{sub:Profiling your code}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Code profiling}

\begin{block}{timeit (only in ipython)}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: import numpy as np

In [2]: a = np.arange(1000)

In [3]: %timeit a ** 2
100000 loops, best of 3: 5.73 us per loop

In [4]: %timeit a ** 2.1
1000 loops, best of 3: 154 us per loop

In [5]: %timeit a * a
100000 loops, best of 3: 5.56 us per loop
\end{minted}

%-------------------------------END CODE

\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Profiler}
This is very useful for large programs.
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
# For this example to run, you also need the 'ica.py' file

import numpy as np
from scipy import linalg
from ica import fastica

def test():
    data = np.random.random((5000, 100))
    u, s, v = linalg.svd(data)
    pca = np.dot(u[:10, :], data) 
    results = fastica(pca.T, whiten=False)
test()
\end{minted}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Profiler \%run -t}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: %run -t demo.py

IPython CPU timings (estimated):
    User  :    14.3929 s.
    System:   0.256016 s.
\end{minted}


\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Profiler \%run -p}
\small
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [2]: %run -p demo.py

      916 function calls in 14.551 CPU seconds

Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1   14.457   14.457   14.479   14.479 decomp.py:849(svd)
     1    0.054    0.054    0.054    0.054 {method 'random_sample' of 'mtrand.RandomState' objects}
     1    0.017    0.017    0.021    0.021 function_base.py:645(asarray_chkfinite)
    54    0.011    0.000    0.011    0.000 {numpy.core._dotblas.dot}
     2    0.005    0.002    0.005    0.002 {method 'any' of 'numpy.ndarray' objects}
\end{minted}

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Line profiler}
The Line Profiler tells us from where our code is called! Save this program as demo.py

\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
@profile
def test():
    data = np.random.random((5000, 100))
    u, s, v = linalg.svd(data)
    pca = np.dot(u[:10, :], data)
    results = fastica(pca.T, whiten=False)
\end{minted}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Line Profiler}

\tiny
\begin{minted}[bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{bash}
~ $ kernprof.py -l -v demo.py

Wrote profile results to demo.py.lprof
Timer unit: 1e-06 s

File: demo.py
Function: test at line 5
Total time: 14.2793 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    5                                           @profile
    6                                           def test():
    7         1        19015  19015.0      0.1      data = np.random.random((5000, 100))
    8         1     14242163 14242163.0   99.7      u, s, v = linalg.svd(data)
    9         1        10282  10282.0      0.1      pca = np.dot(u[:10, :], data)
   10         1         7799   7799.0      0.1      results = fastica(pca.T, whiten=False)
\end{minted}
Use this Link to retrieve \href{http://packages.python.org/line_profiler/kernprof.py}{Kernprof.py (http://packages.python.org/line\_profiler/kernprof.py)}
\end{frame}


\subsection{Speeding your code} % (fold)
\label{sub:Speeding your code}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Speed up you code}
Some commonly encountered tricks to make code faster.
\begin{itemize}
    \item Vectorizing for loops \\
     \emph{Avoid for loops} using numpy arrays. For this, masks and indices arrays can be useful.
    \item Broadcasting \\
     Use broadcasting to do operations on arrays as small as possible before combining them
    \item In place operations:
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: a = np.zeros(1e7)

In [2]: %timeit global a ; a = 0*a
10 loops, best of 3: 111 ms per loop

In [3]: %timeit global a ; a *= 0
10 loops, best of 3: 48.4 ms per loop

\end{minted}
\end{itemize}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Speed up your code}
\begin{itemize}
    \item Use views, and not copies. \\
    Copying big arrays is as costly as making simple numerical operations on them:
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: a = np.zeros(1e7)

In [2]: %timeit a.copy()
10 loops, best of 3: 124 ms per loop

In [3]: %timeit a + 1
10 loops, best of 3: 112 ms per loop
\end{minted}

\end{itemize}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Speed up your code}
Memory access is cheaper when it is grouped: accessing a big array in a continuous way is much faster than random acces. C or Fortran ordering has a strong effect on matrix access.\\
This example is really nice:
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: c = np.zeros((1e4, 1e4), order='C')

In [2]: %timeit c.sum(axis=0)
1 loops, best of 3: 3.89 s per loop

In [3]: %timeit c.sum(axis=1)
1 loops, best of 3: 188 ms per loop

In [4]: c.strides
Out[4]: (80000, 8)
\end{minted}
\end{frame}



% subsection Speeding your code (end)

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge JUN}
\href{https://www.dropbox.com/s/0bvyrc1zf5x1hhk/jun.txt}{https://www.dropbox.com/s/0bvyrc1zf5x1hhk/jun.txt}
\tiny 
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
GACATCATGGGCTATTTTTAGGGGTTGACTGGTAGCAGATAAGTGTTGAGCTCGGGCTGGATAAGGGCTC
AGAGTTGCACTGAGTGTGGCTGAAGCAGCGAGGCGGGAGTGGAGGTGCGCGGAGTCAGGCAGACAGACAG
ACACAGCCAGCCAGCCAGGTCGGCAGTATAGTCCGAACTGCAAATCTTATTTTCTTTTCACCTTCTCTCT
AACTGCCCAGAGCTAGCGCCTGTGGCTCCCGGGCTGGTGTTTCGGGAGTGTCCAGAGAGCCTGGTCTCCA
GCCGCCCCCGGGAGGAGAGCCCTGCTGCCCAGGCGCTGTTGACAGCGGCGGAAAGCAGCGGTACCCACGC
GCCCGCCGGGGGAAGTCGGCGAGCGGCTGCAGCAGCAAAGAACTTTCCCGGCTGGGAGGACCGGAGACAA
GTGGCAGAGTCCCGGAGCCAACTTTTGCAAGCCTTTCCTGCGTCTTAGGCTTCTCCACGGCGGTAAAGAC
CAGAAGGCGGCGGAGAGCCACGCAAGAGAAGAAGGACGTGCGCTCAGCTTCGCTCGCACCGGTTGTTGAA
CTTGGGCGAGCGCGAGCCGCGGCTGCCGGGCGCCCCCTCCCCCTAGCAGCGGAGGAGGGGACAAGTCGTC
GGAGTCCGGGCGGCCAAGACCCGCCGCCGGCCGGCCACTGCAGGGTCCGCACTGATCCGCTCCGCGGGGA
GAGCCGCTGCTCTGGGAAGTGAGTTCGCCTGCGGACTCCGAGGAACCGCTGCGCACGAAGAGCGCTCAGT
GAGTGACCGCGACTTTTCAAAGCCGGGTAGCGCGCGCGAGTCGACAAGTAAGAGTGCGGGAGGCATCTTA
ATTAACCCTGCGCTCCCTGGAGCGAGCTGGTGAGGAGGGCGCAGCGGGGACGACAGCCAGCGGGTGCGTG
CGCTCTTAGAGAAACTTTCCCTGTCAAAGGCTCCGGGGGGCGCGGGTGTCCCCCGCTTGCCACAGCCCTG
TTGCGGCCCCGAAACTTGTGCGCGCAGCCCAAACTAACCTCACGTGAAGTGACGGACTGTTCTATGACTG
CAAAGATGGAAACGACCTTCTATGACGATGCCCTCAACGCCTCGTTCCTCCCGTCCGAGAGCGGACCTTA
TGGCTACAGTAACCCCAAGATCCTGAAACAGAGCATGACCCTGAACCTGGCCGACCCAGTGGGGAGCCTG
AAGCCGCACCTCCGCGCCAAGAACTCGGACCTCCTCACCTCGCCCGACGTGGGGCTGCTCAAGCTGGCGT
CGCCCGAGCTGGAGCGCCTGATAATCCAGTCCAGCAACGGGCACATCACCACCACGCCGACCCCCACCCA
GTTCCTGTGCCCCAAGAACGTGACAGATGAGCAGGAGGGCTTCGCCGAGGGCTTCGTGCGCGCCCTGGCC
GAACTGCACAGCCAGAACACGCTGCCCAGCGTCACGTCGGCGGCGCAGCCGGTCAACGGGGCAGGCATGG
...
\end{minted}
\end{frame}
\begin{frame}[fragile]\frametitle{Challenge JUN (continued)}
\tiny 
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
...
TGGCTCCCGCGGTAGCCTCGGTGGCAGGGGGCAGCGGCAGCGGCGGCTTCAGCGCCAGCCTGCACAGCGA
GCCGCCGGTCTACGCAAACCTCAGCAACTTCAACCCAGGCGCGCTGAGCAGCGGCGGCGGGGCGCCCTCC
TACGGCGCGGCCGGCCTGGCCTTTCCCGCGCAACCCCAGCAGCAGCAGCAGCCGCCGCACCACCTGCCCC
AGCAGATGCCCGTGCAGCACCCGCGGCTGCAGGCCCTGAAGGAGGAGCCTCAGACAGTGCCCGAGATGCC
CGGCGAGACACCGCCCCTGTCCCCCATCGACATGGAGTCCCAGGAGCGGATCAAGGCGGAGAGGAAGCGC
ATGAGGAACCGCATCGCTGCCTCCAAGTGCCGAAAAAGGAAGCTGGAGAGAATCGCCCGGCTGGAGGAAA
AAGTGAAAACCTTGAAAGCTCAGAACTCGGAGCTGGCGTCCACGGCCAACATGCTCAGGGAACAGGTGGC
ACAGCTTAAACAGAAAGTCATGAACCACGTTAACAGTGGGTGCCAACTCATGCTAACGCAGCAGTTGCAA
ACATTTTGAAGAGAGACCGTCGGGGGCTGAGGGGCAACGAAGAAAAAAAATAACACAGAGAGACAGACTT
GAGAACTTGACAAGTTGCGACGGAGAGAAAAAAGAAGTGTCCGAGAACTAAAGCCAAGGGTATCCAAGTT
GGACTGGGTTGCGTCCTGACGGCGCCCCCAGTGTGCACGAGTGGGAAGGACTTGGCGCGCCCTCCCTTGG
CGTGGAGCCAGGGAGCGGCCGCCTGCGGGCTGCCCCGCTTTGCGGACGGGCTGTCCCCGCGCGAACGGAA
CGTTGGACTTTTCGTTAACATTGACCAAGAACTGCATGGACCTAACATTCGATCTCATTCAGTATTAAAG
GGGGGAGGGGGAGGGGGTTACAAACTGCAATAGAGACTGTAGATTGCTTCTGTAGTACTCCTTAAGAACA
CAAAGCGGGGGGAGGGTTGGGGAGGGGCGGCAGGAGGGAGGTTTGTGAGAGCGAGGCTGAGCCTACAGAT
GAACTCTTTCTGGCCTGCCTTCGTTAACTGTGTATGTACATATATATATTTTTTAATTTGATGAAAGCTG
ATTACTGTCAATAAACAGCTTCATGCCTTTGTAAGTTATTTCTTGTTTGTTTGTTTGGGTATCCTGCCCA
GTGTTGTTTGTAAATAAGAGATTTGGAGCACTCTGAGTTTACCATTTGTAATAAAGTATATAATTTTTTT
ATGTTTTGTTTCTGAAAATTCCAGAAAGGATATTTAAGAAAATACAATAAACTATTGGAAAGTACTCCCC
TAACCTCTTTTCTGCATCATCTGTAGATACTAGCTATCTAGGTGGAGTTGAAAGAGTTAAGAATGTCGAT
TAAAATCACTCTCAGTGCTTCTTACTATTAAGCAGTAAAAACTGTTCTCTATTAGACTTTAGAAATAAAT
GTACCTGATGTACCTGATGCTATGGTCAGGTTATACTCCTCCTCCCCCAGCTATCTATATGGAATTGCTT
ACCAAAGGATAGTGCGATGTTTCAGGAGGCTGGAGGAAGGGGGGTTGCAGTGGAGAGGGACAGCCCACTG
AGAAGTCAAACATTTCAAAGTTTGGATTGTATCAAGTGGCATGTGCTGTGACCATTTATAATGTTAGTAG
AAATTTTACAATAGGTGCTTATTCTCAAAGCAGGAATTGGTGGCAGATTTTACAAAAGATGTATCCTTCC
AATTTGGAATCTTCTCTTTGACAATTCCTAGATAAAAAGATGGCCTTTGCTTATGAATATTTATAACAGC
ATTCTTGTCACAATAAATGTATTCAAATACCAA
\end{minted}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{JUN TF gene}
From the above gene, write a code that counts: 
\begin{itemize}
    \item Nuclotide frequency table.
    \item BiNucleotide frequency table. 
    \item TriNucleotide frequency table. 
\end{itemize}
Split your code in several functions. Use the profiler and line profiler to measure the performance of your code. \\
How much your code would spend to process the complete human genome ($3.5\cdot 10^9$ Nucleotides)?
\end{block}



\end{frame}

% subsection Profiling your code (end)


\section{SymPy}
\subsection{First Steps with SimPy} % (fold)
\label{sub:First Steps with SimPy}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Symbolic Mathematics in Python}

\begin{block}{Sympy}
SymPy is a Python library for symbolic mathematics. Implements a computer algebra system comparable with Mathematica or Maple.\\
It has a separate website at \href{http://sympy.org}{http://sympy.org}
\end{block}
Capabilities:
\begin{itemize}
    \item Evaluate expressions with arbitrary precision.
    \item Perform algebraic manipulations on symbolic expressions.
    \item Perform basic calculus with symbolic expressions including limits, differentiation and integration.
    \item Solve polynomial and transcendental equations.
    \item Solve some differential equations.
\end{itemize}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Introduction}
\begin{block}{Rational class}
SymPy offers the representation of a Rational class as a pair of two integers, so:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sympy import *
r = Rational(1,2)
r
r.evalf()
@
%-------------------------------END CODE
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Introduction}
\begin{block}{mpmath}
SymPy uses \href{http://code.google.com/p/mpmath/}{mpmath}. \\ 
Mpmath is a pure-Python library for multiprecision floating-point arithmetic. It provides an extensive set of transcendental functions ($f(x)=x^\pi$), unlimited exponent sizes, complex numbers, interval arithmetic, numerical integration and differentiation, root-finding, linear algebra, and much more. \\
This allows to perform computations using arbitraty precision atithmetic, including the evaluation of $e$, $\pi$, and the inclusion of $\infty$ as a symbol itself through the $oo$. 
\end{block}
\end{frame}

\begin{frame}[fragile]\frametitle{Introduction}

%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
pi**2
pi.evalf()
pi.evalf(60)
oo > 10000
oo+10000
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{2 mins challenge}
\begin{itemize}
    \item Create two rationals corresponding to $1/2$ and $2/3$ and sum them. 
    \item  Compute the value of $\sqrt{2 \pi \over 3}$ with 30 decimals.   
\end{itemize}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Symbols}
Symbolic variables must be declared explicitly. 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sympy import *
x = Symbol('x')
y = Symbol('y')
@
%-------------------------------END CODE
And then comes the magic:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x-y+x-y-x+y+y
@
%-------------------------------END CODE
\end{frame}

% subsection First Steps with SimPy (end)
\subsection{Algebraic manipulations} % (fold)
\label{sub:Algebraic manipulations}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Expand}
Expand expands powers and multiplications: 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
(x+y)**2
expand((x+y)**2)
expand((x)**2, complex=True)
expand(cos(x+y), trig=True)
@
%-------------------------------END CODE
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Simplify}
\begin{block}{simplify()}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
simplify((x+x*y)/x)
@
%-------------------------------END CODE
There are specific targeted simplify functions:
\begin{description}
    \item[powsimp] Simplification  of exponents.
    \item[trigsimp] Trigonometric expressions.
    \item[logcombine] $\log(x)+\log(y) = \log(xy)$ and $a \log(x) = \log(x^a)$
    \item[radsimp] Rationalize the denominator.
    \item[together] Rational expressions (\emph{No heroic measures are taken to minimize degree of the resulting numerator and denominator.}, sic.)
    
\end{description}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{challenge}
\begin{block}{2 min challenge}

\begin{itemize}
    \item Compute the expanded form of $(x+xy)^3$
    \item Simplify the expression $\sin(x) \over \cos(x)$
\end{itemize}

\end{block}

\end{frame}





% subsection Algebraix manipulations (end)

\subsection{Calculus} % (fold)
\label{sub:Calculus}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Limits}
Interestingly, limits are very easy to use in SymPy, just use the sintax:
\begin{block}{limits}
limit(function, variable, point)
\end{block}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Limits}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x = Symbol('x')
limit(sin(x)/x, x, 0)
limit(x, x, oo)
limit(1/x, x, oo)
limit(x**x, x, 0)
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Differentiation}

You can differentiate any SymPy expression using:

\begin{block}{differentiation}
diff(func,var,n)
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Differentiation}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x = Symbol('x')
diff(sin(x), x)
diff(sin(2*x), x)
diff(tan(x), x)
diff(sin(2*x), x, 3)
@
%-------------------------------END CODE

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Series Expansion}
SymPy also knows how to compute the Taylor series of an expression at a point. Use :
\begin{block}{series}
series(expr,var)
\end{block}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x = Symbol('x')
series(cos(x), x)
@
%-------------------------------END CODE

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Integration}
\begin{block}{Integration}
SymPy has support for indefinite and definite integration of transcendental elementary and special functions via integrate() facility, which uses powerful extended Risch-Norman algorithm and some heuristics and pattern matching.
\end{block}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x = Symbol('x')
integrate(2*x**4,x)
integrate(cos(x),x)
integrate(log(x)*x,x)
integrate(log(x)*x,(x,0,1))
@
%-------------------------------END CODE
\end{frame}



% subsection Calculus (end)
\subsection{Equation solving} % (fold)
\label{sub:Equation solving}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Solver}

SymPy is able to solve algebraic equations, in one and several variables:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x = Symbol('x')
y = Symbol('y')
solve(x**4 - 1, x)
solve([x + 5*y - 2, -3*x + 6*y - 15], [x, y])
solve(exp(x) + 1, x)
@
%-------------------------------END CODE

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Factor}
For solving polinomials, also consider the use of \verb|factor|:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
x = Symbol('x')
f = x**4 - 3*x**2 + 1
factor(f)
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{2 mins challenge}
Could you solve the system of equations: 
\begin{align}
    x+y&=2 \\
    2x+y &= 0
\end{align}
\end{block}

\end{frame}


% subsection Equation solving (end)

\subsection{Linear Algebra} % (fold)
\label{sub:Linear Algebra}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Matrix support}
Matrices can be created as instances from the Matrix class: 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sympy import Matrix
Matrix([[1,0],[0,1]])
@
%-------------------------------END CODE
But... 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
A = Matrix([[1,x],[y,1]])
A.det()
A**2
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
%\begin{frame}[fragile]\frametitle{Differential Equations}
%----------------------------FRAME------------------------------------
%SymPy is capable of solving (some) Ordinary Differential Equations through sympy.ode :
%-------------------------------CODE
%<<term=TRUE,echo=TRUE,fig=FALSE>>=
%from sympy.ode import dsolve
%eq=f(x).diff(x, x) + f(x)
%dsolve(f(x).diff(x, x) + f(x), f(x))
%@
%-------------------------------END CODE


%\end{frame}


% subsection Linear Algebra (end)

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}
\begin{block}{Differential Equations}
Create a Generic function $f$
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
f = Function("f")
f(x)
f(x).diff()
e = Eq( f(x).diff(x,x) + 9*f(x) , 0)
e
dsolve(e,f(x))
@
%-------------------------------END CODE

\end{block}

\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}\frametitle{Questions}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.6\textwidth]{figs/question}
\end{figure}
\end{frame}


\end{document}
\documentclass[10pt, colorlinks]{beamer}
  % compress
  %\documentclass[handout,xcolot=pdftex,dvipsnames,table]{beamer}
\definecolor{mybg}{RGB}{255,255,204}
\usepackage{minted}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage{amsmath}


 % \usepackage{beamerthemesplit}

%\usemintedstyle{trac}
\input{format.tex}

\title{ Python in a Nutshell}
\subtitle
 {Part IV: Scikits } % (optional)

\input{header.tex} %

\begin{document}


\begin{frame}[plain]
   %  \titlepage
   \maketitle
\end{frame}

\begin{frame}[allowframebreaks]{Contents}
  \tableofcontents
  % You might wish to add the option [pausesections]
 \note[options]{aixo son notes}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Machine Learning}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{figs/machine}
\end{figure}
\end{frame}



\section{Introduction to Python Scikits}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scikits}

\begin{itemize}
    \item SciKits (short for SciPy Toolkits), are add-on packages for SciPy, hosted and developed separately from the main SciPy distribution.
    \item The SciKits cover a broad spectrum of application domains, including financial computation, audio processing, geosciences, computer vision, engineering, machine learning, medical computing and bioinformatics.
    \item All SciKits are available under the 'scikits' namespace and are licensed under OSI-approved licenses.
    \item Packages are packaged as toolkits (instead of in the main, monolithic SciPy distribution) when:
\begin{enumerate}
    \item The package is deemed too specialized to live in SciPy itself or

    \item The package has a GPL (or similar) license which is incompatible with SciPy's BSD license or

    \item The package is meant to be included in SciPy, but development is still in progress.
\end{enumerate}
\end{itemize}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scikits}

\begin{block}{Avaliable kits}
The list of available kits can be found at  \\ 
    \centering \href{http://scikits.appspot.com/scikits}{http://scikits.appspot.com/scikits}.
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Scikits}
\begin{block}{Main scikits}
\begin{description}
    \item[scikit-aero]  Aeronautical engineering calculations in Python.
    \item[scikit-image] Image processing routines for SciPy.
    \item[scikit-rf] Object Oriented Microwave Engineering.
    \item[audiolab] A python module to make noise from numpy arrays (sic).
    \item[timeseries] Time series manipulation.
    \item[learn] Machine learning Sci-kit. 
\end{description}
\end{block}

\end{frame}

\subsection{pandas} % (fold)
\label{sec:scikit timeseries}



%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{pandas}
\begin{block}{timeseries}
The scikits.timeseries module is no longer undergoing active development. There is an outstanding list of bugs that are unlikely to be fixed. The plan is for the core functionality of this module to be implemented in pandas.
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{pandas}
\begin{block}{Python Data Analysis Library (pandas)}
Python has long been great for data munging and preparation, but less so for data analysis and modeling. \emph{pandas} helps fill this gap, enabling you to carry out your entire data analysis workflow in Python without having to switch to a more domain specific language like R.
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{pandas features}
\begin{block}{pandas features}
\begin{itemize}
    \item A fast and efficient DataFrame object for data manipulation with integrated indexing.
    \item Tools for reading and writing data between in-memory data structures and different formats: CSV and text files, Microsoft Excel, SQL databases, and the fast HDF5 format.
    \item Intelligent data alignment and integrated handling of missing data: gain automatic label-based alignment in computations and easily manipulate messy data into an orderly form.
    \item High performance merging and joining of data sets.
\end{itemize}
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{pandas}
\small
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [1]: index = date_range('1/1/2000', periods=8)

In [2]: s = Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])

In [3]: df = DataFrame(randn(8, 3), index=index,
   ...:                columns=['A', 'B', 'C'])
   ...:

In [4]: wp = Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
   ...:            major_axis=date_range('1/1/2000', periods=5),
   ...:            minor_axis=['A', 'B', 'C', 'D'])
   ...:
\end{minted}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{pandas}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
In [39]: df
Out[39]: 
        one     three       two
a  2.213700       NaN -1.436616
b  0.115002  0.640476 -1.107900
c  0.008462  0.697707  0.844137
d       NaN  0.331810 -0.429735

In [40]: df.mean(0)
Out[40]: 
one      0.779055
three    0.556664
two     -0.532528

\end{minted}

\end{frame}

% section scikit timeseries (end)
%
\subsection{audiolab} % (fold)
\label{sec:audiolab}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{audiolab}
\begin{block}{audiolab}
Is essentially a  wrapper around Erik de Castro Lopo's excellent libsndfile:\\
    \centering \href{http://www.mega-nerd.com/libsndfile/}{http://www.mega-nerd.com/libsndfile/} 
\end{block}
\small
\begin{block}{}
Audiolab is a python package to read/write audio files from numpy arrays. Matlab have functions such as wavread, wavwrite, soundsc, etc. Main features are:
\begin{itemize}
    \item Reading all formats supported by sndfile directly into numpy arrays.
    \item Writing all formats supported by sndfile directly from numpy arrays.
    \item A matlab-like API (e.g. wavread) for some file formats. Wav, aiff, flac, au, and ogg formats are supported.
    \item A play function to output data from numpy array into the sound device of your computer (Only ALSA for linux and CoreAudio for Mac OS X is implemented ATM).
\end{itemize}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{audiolab overview}
\small \begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
from audiolab import wavread
data, fs, enc = wavread('test.wav')
import numpy as np
from scikits.audiolab import Sndfile

f = Sndfile('test.wav', 'r')

# Sndfile instances can be queried for the audio file meta-data
fs = f.samplerate
nc = f.channels
enc = f.encoding

# Reading is straightforward
data = f.read_frames(1000)

# This reads the next 1000 frames, e.g. from 1000 to 2000,
# but as single precision
data_float = f.read_frames(1000, dtype=np.float32)
\end{minted}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{audiolab}

\small \begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import numpy as np
from scikits.audiolab import Format, Sndfile

filename = 'foo.wav'

# Create some data to save as audio data: one 
# second of stereo white noise
data = np.random.randn(48000, 2)

# Create a Sndfile instance for writing wav files @ 48000 Hz
format = Format('wav')
f = Sndfile(filename, ' w', format, 2, 48000)

# Write the first 500 frames of the signal. 
# Note that the write_frames method
# uses tmp's numpy dtype to determine how to 
# write to the file; sndfile also
# converts the data on the fly if necessary
f.write_frames(data[:500]); f.close()
\end{minted}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{audiolab}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import numpy as np
from scikits.audiolab import play

# output one second of stereo 
#    gaussian white noise at 48000 hz

play(0.05 * np.random.randn(2, 48000))
\end{minted}


\end{frame}

% section audiolab (end)


\section{scikit-learn} % (fold)
\label{sec:scikit-learn}

\subsection{Datasets in sklearn} % (fold)
\label{sub:Datasets in sklearn}

% subsection Datasets in sklearn (end)
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Introduction}
\begin{block}{Datasets}
There are three different datasets in sklearn:
\begin{enumerate}
    \item Sample images.
    \item Toy Datasets.
    \item Sample Generators.
\end{enumerate}
\end{block}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Image sets}
The scikit also embed a couple of sample JPEG images (china and flower) published under Creative Commons license by their authors.
\begin{columns}[c]
\column{0.6\textwidth}

%-------------------------------CODE
\small
<<term=False,echo=TRUE,fig=FALSE>>=
import numpy as np
import pylab as pl
from sklearn.datasets import load_sample_image
china = load_sample_image("china.jpg")
@
%-------------------------------END CODE
\column{0.4\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.imshow(china)
pl.show()
@
%-------------------------------END CODE
\end{columns}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Toy datasets}
\begin{description}
    \item[load\_boston()] \textcolor{green}{Regression} Load and return the boston house-prices dataset.
    \item[load\_iris()] \textcolor{red}{Classification} Load and return the iris dataset.
    \item[load\_diabetes()] \textcolor{green}{Regression} Load and return the diabetes dataset.
    \item[load\_digits()] \textcolor{red}{Classification} Load and return the digits dataset.
     \item[load\_linnerud()] \textcolor{green}{Multivariate Regression} 	Load and return the linnerud dataset.
\end{description}
These functions return a \emph{bunch} (which is a dictionary that is accessible with the \emph{dict.key} syntax). All datasets have at least two keys, 
\begin{itemize}
    \item \textcolor{red}{data}, containing an array of shape $n$ samples $\times$ $n$ features and 
    \item \textcolor{red}{target}, a numpy array of length $n$ features, containing the targets.
\end{itemize}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Data Generators}
A number of functions exists to create the most esoteric data distributions: 
\begin{description}
    \item[make\_classification()] n-class classification problem (+ multilabel).
    \item[make\_regression()] Generate a regression problem.
    \item[make\_swiss\_roll()] Generate swiss roll datasets.
    \item[make\_s\_curve]  Generates S curve datasets.
\end{description}
All of them returning a tuple $(X, y)$ consisting of a $n$ samples $\times$ $n$ features numpy array $X$ and an array of length $n$ samples containing the targets $y$.

\end{frame}



%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Data Generators}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.85\textwidth]{figs/randomdata}
\end{figure}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Challenge}

\begin{block}{5 mins challenge}
Generate and plot a dataset with two non-overlapping swiss rolls on $\mathbb{R}^3$ with 1000 samples each.  
\end{block}
Tip, you can generate a rotation matrix with help of this function: 

%-------------------------------CODE
<<term=False,echo=TRUE,fig=FALSE>>=
import numpy as np
def rot(angle, R = np.zeros((3,3))):
    cx, cy, cz = np.cos(angle)
    sx, sy, sz = np.sin(angle)
    R.flat = (cx*cz -sx*cy*sz, cx*sz + sx*cy*cz, sx*sy,\
     -sx*cz - cx*cy*sz, -sx*sz +cx*cy*cz, cx*sy,\
     sy*sz, -sy*cz, cy)
    return R
@
%-------------------------------END CODE

%-------------------------------END CODE
\end{frame}
<%
import time as time
import numpy as np
import pylab as pl
import mpl_toolkits.mplot3d.axes3d as p3
from sklearn.cluster import Ward
from sklearn.datasets.samples_generator import make_swiss_roll

# Generate data (swiss roll dataset)
n_samples = 1000
noise = 0.05
X1, _ = make_swiss_roll(n_samples, noise)
X2, _ = make_swiss_roll(n_samples, noise)

# Shrink second dimension
X1[:, 1] *= .1
X2[:, 1] *= .1
def myplot(X):
    fig = pl.figure()
    ax = p3.Axes3D(fig)
    ax.view_init(7, -80)
    ax.plot3D(X[:, 0], X[:, 1], X[:, 2],
              'o', color='blue')


R = rot((0,np.pi/4,np.pi/4))
Y= np.concatenate((X1,2+X2.dot(R)))
myplot(Y)
%>
%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{}
\begin{columns}[c]
\column{\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE

\end{columns}
\end{frame}

\subsection{Unsupervised Learning} % (fold)
\label{sec:Clustering}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Introduction to clustering in python}
\begin{block}{Clustering}
Or Cluster Analysis, is the task of grouping a set of objects in such a way that objects in the same groups (clusters) are more similar to each other than to those in other groups.
\end{block}
It is useful in a large amount of applications:
   \begin{itemize}
       \item Exploratory analysis.
        \item Machine Learning \& Pattern Recognition.
        \item Image analysis.
        \item Bioinformatics.
        \item Market Analysis.
   \end{itemize}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Clustering}
\begin{center}
    
\only<1>{\centering  \includegraphics[scale=0.8]{figs/similitude/Slide1} }
\only<2>{\centering  \includegraphics[scale=0.7]{figs/similitude/Slide4} }
\only<3>{\centering  \includegraphics[scale=0.8]{figs/similitude/Slide5} }
\only<4>{\centering  \includegraphics[scale=0.8]{figs/similitude/Slide3} }
\only<5>{\centering  \includegraphics[scale=0.8]{figs/similitude/Slide2} }

\end{center}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Clustering algorithms in sklearn}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{figs/clustering}
\end{figure}
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Notes on Clustering input}
\begin{block}{Input data formats}
One important thing to note is that the algorithms implemented in this module take different kinds of matrix as input.
    \begin{itemize}
    \item \textcolor{blue}{MeanShift and KMeans} take data matrices of shape [n\_samples, n\_features]. The are obtained from  \verb|sklearn.feature\_extraction| module. 
    \item \textcolor{blue}{AffinityPropagation and SpectralClustering} take similarity matrices of shape [n\_samples, n\_samples]. These are obtained from  \verb|sklearn.metrics.pairwise module|. 
    \end{itemize} 
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{sklearn.metrics.pairwise}
\begin{block}{sklearn.metrics.pairwise}
Contains both distances and kernels. There are a number of ways to convert between a distance metric and a similarity measure, such as a kernel. Let $D$ be the distance, and $S$ be the kernel:
\begin{align}
    s(x,y) &= e^{-d(x,y) \over \gamma } \\
    s(x,y) &= \frac{1}{\frac{d(x,y)}{max(D)}} 
\end{align}
\end{block}
\pause
\begin{block}{sklearn.metrics.pairwise.rbf\_kernel(X, Y=None, gamma=0)}
Compute the rbf (gaussian) kernel between X and Y:
\begin{equation}
    K(x,y) = e^{-\gamma ||x-y||^2}
\end{equation}
\end{block}

\end{frame}




%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{{Learning Clustering in python}}
\begin{columns}[c]
\column{0.5\textwidth}
Let's recover our previous challenge (the two swiss rolls). 

\begin{block}{}
Could we automagically assign each sample to an egg roll?  Open your ipython and:
\begin{itemize}
    \item Use first k-means.
    \item Try another clustering algorithm.
\end{itemize}
\end{block}

\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
myplot(Y)
pl.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

\subsection{Principal Component Analysis} % (fold)
\label{sec:}
%----------------------------FRAME 2 cols + header (box)-------------
\begin{frame}[fragile]\frametitle{Principal Components Analysis}
\begin{block}{PCA}
PCA is an orthogonal linear transformation that creates a data model with a new coordinate system with a criteria for maximum variance captured.
 \begin{equation}
     w_1 = \arg\max_{||w||=1} \left\{ E(w^T X)^2\right\}
 \end{equation}
\end{block}
\end{frame}


\begin{frame}
  \frametitle{Principal Component Analysis }
  \begin{block}{}
    Most popular and commonly used methods. Sometimes included in the
    ``Factor Analysis'' methods.
  \end{block}
  \begin{itemize}
  \item<+-> It's the second most main tool for visualization
    \begin{itemize}
    \item (First is always to plot the signals!)
    \end{itemize}
  \item<+-> Main goal of PCA is to capture main directions of variance
    in input space.
  \item<+-> Dimensionality reduction:
    \begin{itemize}
    \item<+-> Allows for projecting the dataset onto a low dimensional subspace.
    \item<+-> Form of compression, or data modeling.
    \item<+-> Filtering.
    \end{itemize}

  \end{itemize}
\end{frame}



\begin{frame}
    \frametitle{Principal Component Analysis }
    \begin{center}
        \centering \includegraphics[width=0.6\textwidth]{figs/center}
    \end{center}  

\end{frame}

\begin{frame}
    \frametitle{Principal Component Analysis }
    
    \begin{center}
        \centering \includegraphics[width=0.6\textwidth]{figs/pca1}
    \end{center}        
    
\end{frame}


\begin{frame}
    \frametitle{PCA }
    \begin{center}
        \centering \includegraphics[width=0.6\textwidth]{figs/pca2}
    \end{center}
\end{frame}

 


\begin{frame}
    \frametitle{PCA }
    \begin{center}
        \centering \includegraphics[width=\textwidth]{figs/pca3}
    \end{center}
    \begin{columns}
        \pause      \begin{column}{0.3\textwidth}
            \begin{center}
                \centering \includegraphics[width=\columnwidth]{figs/pcab1}
            \end{center}            
        \end{column}
        \pause         \begin{column}{0.3\textwidth}
            \begin{center}
                \centering \includegraphics[width=\columnwidth]{figs/pcab2}
            \end{center}            
        \end{column}
        \pause         \begin{column}{0.3\textwidth}
            \begin{center}
                \centering \includegraphics[width=\columnwidth]{figs/pcab3}
            \end{center}            
        \end{column}     
    \end{columns}
\end{frame}

%----------------------------FRAME 2 cols + header (box)-------------
\begin{frame}[fragile]\frametitle{The Iris dataset}
\begin{block}{Iris dataset}
The iris dataset is a classical classification task consisting in identifying 3 different types of irises (Setosa, Versicolour, and Virginica) from their petal and sepal length and width.
\end{block}
\begin{columns}[c]
\column{0.5\textwidth}
%-------------------------------CODE
\small
<<term=True,echo=TRUE,fig=FALSE>>=
import numpy as np
from sklearn import datasets
import matplotlib.pylab as pl
iris = datasets.load_iris()
X = iris.data
y = iris.target
X[:2,:]
np.unique(y)
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=True,fig=False>>=
pl.scatter(X[:, 0], X[:, 1],
     c=y)
pl.xlabel('Sepal length')
pl.ylabel('Sepal width')
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Iris Dataset}
\begin{columns}[c]
\column{0.4\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/iris}
\column{0.6\textwidth}

%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{PCA in python }
It's very easy now to construct the PCA projection:
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import decomposition
pca = decomposition.PCA(n_components=2)
pca.fit(X)
T = pca.transform(X)
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME 2 cols------------------------------
\begin{frame}[fragile]\frametitle{PCA in python}

\begin{columns}[c]
\column{0.5\textwidth}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=False>>=
import pylab as pl
pl.scatter(T[:, 0], T[:, 1], \
    c=y) 
pl.xlabel('1PC')
pl.ylabel('2PC')
@
%-------------------------------END CODE
\column{0.5\textwidth}
%-------------------------------CODE
<<term=FALSE,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

% section  (end)

\subsection{Supervised Learning} % (fold)
\label{sec:Classfication}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Supervised Learning}
\begin{block}{Supervised Learning}
Consists in learning the link between two datasets:
\begin{itemize}
    \item An observed data $X$ and
    \item  A variable $y$ usually called target or labels. 
\end{itemize}
\end{block}
\end{frame}





%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Classification algorithms in sklearn}
\begin{center}
 \begin{figure}[!htb]
   
   
\centering    \includegraphics[width=1.1\textwidth]{figs/classifiers}
\end{figure}
\end{center} 
\
\end{frame}

% section Classfication (end)


%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-nearest neighbours }
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import neighbors
knn = neighbors.KNeighborsClassifier(7)
knn.fit(T, y)
knn.predict([[0.1, 0.2]])
yPred = knn.predict(T)
(yPred==y).mean()
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Support Vector Classification}
%-------------------------------CODE
<<label='svm',term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import svm
C,gamma = 1,0.7
svcg = svm.SVC(kernel='rbf', gamma=gamma, C=C).fit(T, y)
svcg.predict([-.7,7])
yPred = svcg.predict(T)
(yPred==y).mean()
@
%-------------------------------END CODE
\end{frame}

\subsection{Metrics} % (fold)
\label{ssub:Metrics}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{sklearn.metrics}
\begin{block}{sklearn.metrics}
\begin{description}
    \item[roc\_curve]  Compute Receiver operating characteristic (ROC).
    \item[precision\_recall\_curve] Compute precision-recall pairs for different probability thresholds.
    \item[accuracy\_score] Accuracy classification score.
    \item[confusion\_matrix] Confusion matrix. 
    \item[matthews\_corrcoef] Matthews Correlation coefficient
    \item[classification\_report] Build a text report showing the main classification metrics.
 \end{description}
\end{block}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{sklearn.metrics}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import metrics
metrics.recall_score(yPred,y)
metrics.confusion_matrix(yPred,y)
@
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
metrics.classification_report(yPred,y)
             precision    recall  f1-score   support
          0       1.00      1.00      1.00        50
          1       0.94      0.92      0.93        51
          2       0.92      0.94      0.93        49
navg / total       0.95      0.95      0.95       150
\end{minted}

%-------------------------------END CODE

\end{frame}

% subsubsection Metrics (end)

\subsection{Cross Validation} % (fold)
\label{ssub:Cross Validation}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Cross-validation}
\begin{center}
   \centering
        \includegraphics[width=0.5\textwidth]{figs/imnotlying}
\end{center} 

\end{frame}


\begin{frame}
  \frametitle{Validity and Over-Fitting}
  \begin{block}{}
    In multivariate predictive models, \textcolor{blue}{over-fitting} occurs when a
    large number of predictor variables is fit to a small N of
    subjects.  A model may ``fit'' well or perfectly, even if no real
    relationship.  Simon, JNCI 2003
  \end{block}
  \pause \begin{block}{Direct Consequence of Over-fitting}
    Model performance results are not reproducible in a
    \textcolor{blue}{new} set of data. 
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Over-Fitting}
  \begin{center}
    \centering \includegraphics[width=0.6\textwidth]{figs/2vars}
  \end{center}
\end{frame}



\begin{frame}
  \frametitle{Validation Schemes}
  \begin{center}
    \centering \includegraphics[width=0.7\textwidth]{figs/crossval}
  \end{center}
\tiny{Ransohoff.  Nat Rev Cancer 2004 }
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Cross Validation}
\begin{block}{sklearn.cross\_validation.train\_test\_split}
Split arrays or matrices into random train and test subsets.
\end{block}
\small
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import cross_validation
xTrain, xVal, yTrain, yVal = cross_validation.train_test_split(
    X, y, test_size=0.4)
xTrain.shape,xVal.shape
@
\pause 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import neighbors
knn = neighbors.KNeighborsClassifier(7).fit(xTrain, yTrain)
yPredVal = knn.predict(xVal)
(yPredVal==yVal).mean()
@
%-------------------------------END CODE
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Cross-validation metrics}
Can we compute some statistics on the performance of the classifiers? \verb|cross_val_score| exists! 
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
knn = neighbors.KNeighborsClassifier(1)
recalls = cross_validation.cross_val_score(
    knn, X, y, cv = 6)
recalls
recalls.mean()
recalls.std()
@
%-------------------------------END CODE

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Leave one out}
\begin{block}{LOO}
Each training set is constructed  by taking all samples except sample $k$ and the model validates over $k$. Then just iterate through $k$. 
\end{block}
%-------------------------------CODE
<<term=True,echo=TRUE,fig=FALSE>>=
from sklearn.cross_validation import LeaveOneOut
from sklearn import svm
loo = LeaveOneOut(y.size)
cl = svm.SVC(kernel='linear', C=1)
recalls = [(y[indVal] == cl.fit(X[indTrain,:],y[indTrain]).\
        predict(X[indVal,:])).mean() \
            for indTrain, indVal in loo]
len(recalls)
recalls[:5]
@
%-------------------------------END CODE
\end{frame}

% subsubsection Cross Validation (end)

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-nearest neighbours vs. SVC Challenge}
\begin{block}{Challenge}
\begin{enumerate}
    \item Get all variables from Iris dataset.
    \item Compute a 2D-PCA model of the Iris dataset.
    \item Compute and plot the decision boundaries for a k-NN and SVC classifier of your choice.   
 
\end{enumerate}
\end{block}

Hint: use np.mesgrid() 
\end{frame}




% section Clustering (end)

% section scikit-learn (end)


\section{A Practical Introduction to Scikit-learn} % (fold)
\label{sec:A Practical Introduction to Scikit-learn}





% section A Practical Introduction to Scikit-learn (end)
\begin{frame}
	\setbeamercovered{dynamic}
	\frametitle{  An Eigenfaces Session with python }
This session aims to demonstrate the use of scikit in python using an eigenfaces exercise. 
\begin{enumerate}
    \item First will construct a class for storing the information of the chamber of representatives. 
    \item Later we will import the image dataset, 
    \item compute some descriptive statistics, 
    \item perform an analysis of principal components,
    \item clustering analysis and finally, 
    \item will use a non-linear classifier to assess the gender from just the image of the representative.

\end{enumerate}
\end{frame}



\subsection{Data Description}


\begin{frame}
  \frametitle{www.congreso.es}
  \begin{itemize}
  \item Public database (members of the Chamber of Representatives)
  \item Small  \emph{python} script extracted picture and info for
    each representative
  \end{itemize}
  
 \only<1>{\includegraphics[width=0.75\textwidth]{figs/congreso}}
 \only<2>{\includegraphics[width=0.8\textwidth]{figs/dipulassalle}}
 \only<3>{\includegraphics[width=0.8\textwidth]{figs/diputxell}}
 \only<4>{\includegraphics[width=0.8\textwidth]{figs/dipujose}}
 \only<5>{\includegraphics[width=0.8\textwidth]{figs/dipurajoy}}

\end{frame}




\begin{frame}
  \frametitle{www.congreso.es}
  \begin{itemize}
  \item Images imported and converted to B/W
  \item 350 members, $86 \times 85 =7310$ pixels
  \end{itemize}
  \includegraphics[width=0.85\textwidth]{figs/features}  
\end{frame}

\subsection{Importing Data}


\begin{frame}
	\setbeamercovered{dynamic}
	\frametitle{  Preparing to import the data}
	We will need to define some classes to prepare the image readout. A nice way of doing this is defining a \emph{Diputado} class, followed by a \emph{Parlamento}	
	A \emph{Diputado}  has a Name, Surnames, ID, Picture, Gender and Political Affiliation.
\end{frame}

\begin{frame}[fragile,allowframebreaks]
	\setbeamercovered{dynamic}
	\frametitle{ A Diputado class definition}
\small
\begin{columns}
\column{0.5\textwidth}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
class Diputado(object):
    def __init__(self,ind,fileRoot="./"):
        self.name=""
        self.surname=""
        self.ind=ind
        self.picfile=""        
        self.party=""
        self.gender=""
        self.fileRoot=fileRoot
        self.ext='c.jpg'
    def setName(self,name):
        self.name=name
    def setSurname(self,surname):
        self.surname=surname
    def setParty(self,party):
        self.party=party
    def setGender(self,gender):
        self.gender=gender
\end{minted}
\column{0.5\textwidth}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
    def getName(self):
        return self.name
    def getSurname(self): 
        return self.surname
    def getInd(self):
        return self.ind
    def getPicfile(self):
        return self.fileRoot + str(self.ind) + self.ext
    def getParty(self):
        return self.party
    def getGender(self):
        return self.gender
\end{minted}
\end{columns}
\end{frame} 


<%
class Diputado(object):
    def __init__(self,ind,fileRoot="./"):
        self.name=""
        self.surname=""
        self.ind=ind
        self.picfile=""        
        self.party=""
        self.gender=""
        self.fileRoot=fileRoot
        self.ext='c.jpg'
    def setName(self,name):
        self.name=name
    def setSurname(self,surname):
        self.surname=surname
    def setParty(self,party):
        self.party=party
    def setGender(self,gender):
        self.gender=gender
    def getName(self):
        return self.name
    def getSurname(self): 
        return self.surname
    def getInd(self):
        return self.ind
    def getPicfile(self):
        return self.fileRoot + str(self.ind) + self.ext
    def getParty(self):
        return self.party
    def getGender(self):
        return self.gender
%>

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Parlament class}
%-------------------------------CODE
\tiny
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
class Parlament(object):
    def __init__(self):
        self.elements=[]
        self.inds=[]
        self.ndips=0
    def add(self, diputado):
        self.elements.append(diputado)
        self.inds.append(diputado.getInd())
        self.ndips +=1
    def getInds(self):
        return [self.elements[i].getInd() for i in range(self.ndips)]
    def len(self):
        return len(self.elements)
    def __getitem__(self, key):
        if isinstance(key, slice):
            indices = key.indices(self.ndips)
            return [self[ii] for ii in xrange(*key.indices(self.len()))] 
        else:
            return self.elements[key]
    def getName(self,key):
        return self.elements[key].getName()
\end{minted}

<%
class Parlament(object):
    def __init__(self):
        self.elements=[]
        self.inds=[]
        self.ndips=0
    def add(self, diputado):
        self.elements.append(diputado)
        self.inds.append(diputado.getInd())
        self.ndips +=1
    def getInds(self):
        return [self.elements[i].getInd() for i in range(self.ndips)]
    def len(self):
        return len(self.elements)
    def __getitem__(self, key):
        if isinstance(key, slice):
            indices = key.indices(self.ndips)
            return [self[ii] for ii in xrange(*key.indices(self.len()))] 
        else:
            return self.elements[key]
    def getName(self,key):
        return self.elements[key].getName()
        
%>
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Importing data images}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
import csv
with open('db/index.csv','rb') as csvfile:
    r = csv.reader(csvfile, delimiter=';')
    r.next()
    p = Parlament()
    for row in r:
        n = Diputado(int(row[0]),"db/db/")
        n.setName(row[1].strip())
        n.setSurname(row[2].strip())
        n.setGender(row[3].strip())
        n.setParty(row[4].strip())
        p.add(n)

\end{minted}
%-------------------------------CODE
<%
import csv
with open('db/index.csv','rb') as csvfile:
    r = csv.reader(csvfile, delimiter=';')
    r.next()
    p = Parlament()
    for row in r:
        n = Diputado(int(row[0]),"db/db/")
        n.setName(row[1].strip())
        n.setSurname(row[2].strip())
        n.setGender(row[3].strip())
        n.setParty(row[4].strip())
        p.add(n)
%>
%-dd-----------------------dd-------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Let's see what we have}
%-------------------------------CODE
<<label='see',term=False,echo=TRUE,fig=FALSE>>=
from scipy import ndimage,misc
from numpy import shape,prod,unique,sqrt
import matplotlib.pyplot as pl
I = ndimage.imread(p[1].getPicfile())
pl.imshow(I)
shape(I)
'|'.join([p[1].getName(), p[1].getSurname(), p[1].getGender()])
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Let's see what we have}
\begin{columns}
    \column{0.7\columnwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{columns}

\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Converting to gray}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=False>>=
I = ndimage.imread(p[1].getPicfile(), flatten=1)
img=pl.imshow(I)
img.set_cmap('gray')
Is=shape(I)
Is
@
%-------------------------------END CODE
\begin{columns}
    \column{0.7\columnwidth}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{columns}
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{And everything is a Signal...}
%-------------------------------CODE

\begin{columns}
    \column{0.8\columnwidth}

<<term=False,echo=TRUE,fig=True>>=
Iv = np.reshape(I,prod(Is))
pl.plot(Iv)
@
\end{columns}

%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Construct the final dataset}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
X=np.array([ np.reshape(ndimage.imread(p[i].getPicfile(), \
                flatten=1), prod(Is)) \
             for i in range(0,p.len())])
shape(X)
Yg=np.array([ p[i].getGender() \
    for i in range(0,p.len())])
Yp=np.array([ p[i].getParty() \
    for i in range(0,p.len())])
Yp[0:5],Yg[0:5],shape(X)
@
%-------------------------------END CODE
\end{frame}



\subsection{Unsupervised Analysis}
\subsubsection{Principal Component Analysis}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Principal Component Analysis}
Now begins the interesting part. Let's try a PCA projection.
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn.decomposition import PCA
from sklearn import preprocessing
sX = preprocessing.scale(X)
ncomp=5
mod=PCA(n_components=ncomp)
mod.fit(sX)
ev = mod.explained_variance_ratio_
print(ev)
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Principal Component Analysis}
The projection over the embedding.
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
Xpca = mod.transform(sX)
Xpca[0:3,:]
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Eigendiputados}
The principal components can be interpreted.
%-------------------------------CODE
\small
<<label='eigen',term=False,echo=TRUE,fig=FALSE>>=
eigendips = mod.components_.reshape((ncomp, Is[0], Is[1]))

pl.figure(figsize=(9 ,3))

pl.subplot(131)
pl.imshow(eigendips[0], cmap=pl.cm.gray)
pl.axis('off')

pl.subplot(132)
pl.imshow(eigendips[1], cmap=pl.cm.gray)
pl.axis('off')

pl.subplot(133)
pl.imshow(-eigendips[2], cmap=pl.cm.gray)
pl.axis('off')

pl.subplots_adjust(wspace=0.01, hspace=0.01, top=1, bottom=0, left=0, right=1)
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Eigendiputados}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Score plots}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=FALSE>>=
colors=['blue','red']
clut = dict(zip(['M','H'],['red','blue']))
""" for one shot plot cols=[ clut[i] for i in Yg]"""

pl.scatter(Xpca[np.where(Yg=='H'),0],\
    Xpca[np.where(Yg=='H'),1],c='red')
pl.scatter(Xpca[np.where(Yg=='M'),0],\
    Xpca[np.where(Yg=='M'),1],c='blue')
pl.legend(('M','H'))
pl.xlabel('1PC ('+ "%s" % float( "%2.1g" % (100*ev[0])) +"%)")
pl.ylabel('2PC ('+ "%s" % float( "%2.1g" % (100*ev[1])) +"%)")
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Score plots}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{frame}

\subsubsection{Clustering}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-means}
With the data already imported, it's easy to group similar pictures with a clustering algorithm.
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import cluster

k_means =  cluster.KMeans(k=8,n_init=10)
k_means.fit(Xpca)

pl.scatter(Xpca[:,0],Xpca[:,1],c=k_means.labels_.astype(np.float))
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-means}
%-------------------------------CODE
<<term=False,echo=False,fig=True>>=
pl.show()
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-means}
\begin{block}{}
We can plot the samples that have been grouped within the same cluster. For doing so we have to reshape the vectors corresponding to each sample matching the original images. This is extremely easy to do in python!
\end{block}
\begin{minted} [bgcolor=mybg,frame=lines,bgcolor=mybg,frame=lines,mathescape]{python}
def plotg(g):
    indg = np.where(k_means.labels_ == g)
    nx = int(sqrt(shape(indg)[1]))+1
    ny = nx+1
    f = pl.figure()

    for e,i in enumerate(indg[0]):
        f.add_subplot(ny,nx,e)
        pl.imshow(X[i,:].reshape(Is), cmap=pl.cm.gray)
        pl.axis('off')
      
\end{minted}

%-------------------------------CODE
<%
def plotg(g):
    indg = np.where(k_means.labels_ == g)
    nx = int(sqrt(shape(indg)[1]))+1
    ny = nx+1
    f = pl.figure()

    for e,i in enumerate(indg[0]):
        f.add_subplot(ny,nx,e)
        pl.imshow(X[i,:].reshape(Is), cmap=pl.cm.gray)
        pl.axis('off')
        pl.subplots_adjust(wspace=0, hspace=0,top=1, bottom=0, left=0, right=1)
%>
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-means groups}
%-------------------------------CODE
\small 
<<term=TRUE,echo=TRUE,fig=True>>=
print(unique(k_means.labels_))
plotg(5), plotg(0)
@
%-------------------------------END CODE
\end{frame}


\subsection{Supervised Analysis}
\subsubsection{k-Nearest Neighbours}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Supervised Analysis}
\begin{block}{}
Next, we will build two classifiers and will try to asses gender just from the feature vector (pixel intensities). We will test k-nn classifier and compare it with a Support Vector Classifier, trained with a grid search. We will also show how to use a cross-validation scheme provided by sklearn scipy toolkit.
\end{block}

\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Supervised analysis}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
nYg = np.array([ int(y=='H') for y in Yg])
print nYg[0:5]
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{k-Neighbors Classifier}
%-------------------------------CODE
<<term=False,echo=TRUE,fig=FALSE>>=
from sklearn.neighbors import KNeighborsClassifier
from sklearn import cross_validation
k_fold = cross_validation.KFold(n=p.len(), k=3, indices=True)
scores = list()
for train_indices, test_indices in k_fold:
    Xtrain = X[train_indices,:]
    Ytrain = nYg[train_indices]
    Xval = X[test_indices,:]
    Yval = nYg[test_indices]
    knn = KNeighborsClassifier()
    knn.fit(Xtrain,Ytrain)
    scores.append(knn.score(Xval,Yval))
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{}
%-------------------------------CODE
\small
<<term=TRUE,echo=TRUE,fig=FALSE>>=
[knn.fit(X[train,:], nYg[train]).score(X[test,:], nYg[test]) 
    for train, test in k_fold]
@
%-------------------------------END CODE
\end{frame}


\subsubsection{Support Vector Classification}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Support Vector Classifier}
%-------------------------------CODE
\small
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn import svm
svc = svm.SVC(C=1, kernel='linear')
[svc.fit(X[train,:], nYg[train]).score(X[test,:], nYg[test]) 
    for train, test in k_fold]
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Support Vector Classifier}
In fact, we should cross-validate with some balance on the class folds.
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
k_fold_class_balanced = \
    cross_validation.StratifiedKFold(nYg,k=5)

svc = svm.SVC(C=1, kernel='linear')
[svc.fit(X[train,:], nYg[train]).score(X[test,:], nYg[test]) 
    for train, test in k_fold_class_balanced]
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{SCV tunning}
%-------------------------------CODE
\small 
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn.grid_search import GridSearchCV
gammas = np.logspace(-6, -1, 5)
clf = GridSearchCV(estimator=svc, param_grid=dict(gamma=gammas), n_jobs=-1)
clf.fit(X[train,:], nYg[train]) 
print clf.best_score_
print clf.best_estimator_.gamma
print clf.score(X[test,:], nYg[test])
@
%-------------------------------END CODE
\end{frame}
%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Performance}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn.metrics import classification_report
ypred = clf.predict(X[test,:])
ytest = nYg[test]
ygtest = Yg[test]
print classification_report(ytest, ypred, target_names=['H','M'])
@
%-------------------------------END CODE
\end{frame}

%----------------------------FRAME------------------------------------
\begin{frame}[fragile]\frametitle{Performance}
%-------------------------------CODE
<<term=TRUE,echo=TRUE,fig=FALSE>>=
from sklearn.metrics import confusion_matrix
print confusion_matrix(ytest, ypred)
@
%-------------------------------END CODE
\end{frame}

\end{document}
